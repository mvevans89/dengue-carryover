---
title: "Dengue Infections 2016"
author: "Michelle Evans"
date: '`r format(Sys.Date())`'
output:
  html_document: 
    theme: flatly
    keep_md: true
  
---

This document is for the analysis of both the August and October Trials of Infections of the Dengue Microclimate project in Athens, GA in 2016.

```{r packages and setup}
library(knitr)
knitr::opts_chunk$set(cache=TRUE)
knitr::opts_chunk$set(message=FALSE)
knitr::opts_chunk$set(warning=FALSE)
```

```{r}
library(xtable)
library(tidyr)
library(ggplot2) 
library(lme4) #mixed models
library(car)
library(MASS)
library(gridExtra) #for facet grids later
library(gbm)
library(caret)
library(pROC)
library(corrplot)
library(glmnet)
library(GGally)
library(dplyr)
```

```{r}
colR <- colRural <- "dodgerblue"
colS <- colSuburban <- "gray80"
colU <- colUrban <- "maroon"
```

# Exploratory Visualizations

## Comparing Seasons in Plots

```{r}
formatData <- function(month){
  #' format infection data
  #' @params month (ie. "august")
  #' @returns dataframe of properly formatted data
  #adjust wingLength
  monthDf <- read.csv(paste0("../../data/infections/raw/", month,"Dengue.csv"))
  #convert wingLength and drop extra columns
  monthDf$Wing <- monthDf$WingLength*monthDf$conversion..mm.bar.
  monthDf <- select(monthDf, -WingLength, -conversion..mm.bar.)
  
  #dpi as factor
  monthDf$DPI <- as.factor(monthDf$DPI)
  
  #add in class and site
  monthDf$site <- as.factor(substr(as.character(monthDf$Individual), 1, 2))
  monthDf$class <- NULL
  for (i in 1:nrow(monthDf)){
    if (substr(monthDf$site[i], 1,1)=="R"){
    monthDf$class[i] <- "Rural"
    } else if (substr(monthDf$site[i], 1,1)=="S"){
    monthDf$class[i] <- "Suburban"
    } else if (substr(monthDf$site[i], 1,1)=="U"){
    monthDf$class[i] <- "Urban"
    }
  }
  monthDf$class <- as.factor(monthDf$class)
  
  #convert Y and N to 1 and 0 for statistics
  levels(monthDf$Body) <- c("NA", 0, 1)
  monthDf$Body <- as.numeric(as.character(monthDf$Body))
  levels(monthDf$Saliva) <- c("NA", 0, 1)
  monthDf$Saliva <- as.numeric(as.character(monthDf$Saliva))
  # august had no contaminated heads, so different corrections
  if (month=="august"){
    levels(monthDf$Head) <- c(0, 1)
  } else levels(monthDf$Head) <- c("NA",0, 1)
  monthDf$Head <- as.numeric(as.character(monthDf$Head))
  
  ##Fix false negatievs
  #adjust so that if saliva is positive, so is head
  #ddjust so that is head is positive, so is body
  monthDf$Head[monthDf$Saliva>0] <- 1
  monthDf$Body[monthDf$Head>0] <- 1
  
  return(monthDf)
}

august <- formatData("august")
oct <- formatData("october")
```

```{r}
seasons <- rbind(august,oct)
seasons$block <- as.factor(c(rep("summer", nrow(august)), rep("fall", nrow(oct))))

seasonSumm <- seasons %>%
  filter(DPI==21) %>%
  #drop individual
  select(-Individual, -site, -Wing, -DPI) %>%
  group_by(block, class) %>%
  summarise_each(funs(mean(.,na.rm=T),sd(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) %>%
  ungroup()
```

```{r}
seasonPlot <- function(bodyPart, summTable=seasonSumm){
  cols <- c(1,2,grep(bodyPart, colnames(summTable)))
  tempLarge <- summTable[,cols]
  colnames(tempLarge)[3:5] <- c("mean", "sd", "se")
    
  tempMean <- tempLarge %>%
    select(-sd,-se) %>%
    spread(block, mean) %>%
    select(-class)
  
  #put summer before fall
  tempMean <- tempMean[,c(2,1)]

  
  rownames(tempMean) <- levels(tempLarge$class)
  tempMean <- t(as.matrix(tempMean))
  
  colvec <- c(rep(colRural,2), rep(colSuburban,2), 
                            rep(colUrban,2))
  
  barCenters <- barplot(tempMean, 
                      beside=T,
                      col=colvec,
                      density = c(40,NA),
                      names.arg=colnames(tempMean),
                      ylim=c(0,0.80)
                      )
  
  tempSE <- tempLarge %>%
    select(-sd,-mean) %>%
    spread(block, se) %>%
    select(-class)
  
   #put summer before fall
  tempSE <- tempSE[,c(2,1)]
  
   tempSE <- t(tempSE)
  
  #add se bars
  segments(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE, lwd = 1.5)
  
  arrows(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE,
         lwd = 1.5, 
         angle = 90,
         code = 3, length = 0.03)
  
  #legend("topright", legend=c("Summer", "Fall"), density = c(40,NA),
       #bty = "n", col = "gray80")
}
```


```{r seasonal plots, eval=F, echo=FALSE}
#pdf(file="../figures/forMS/seasonInfections.pdf", width = 4, height=6, family="sans")
png(file="../figures/forMS/seasonInfections.png", width = 4, height=6, units="in", res=500, family="sans")
par(mfrow=c(3,1), las=1, par(mar=c(5.1,6.1,4.1,2.1)))
#pdf(file="../figures/seasonBody.pdf", width = 8, height=4, family="sans")
seasonPlot(bodyPart="Body")
par(xpd=T)
legend(x=7.5, y=1.0, legend=c("Summer", "Fall"), density = c(40,NA),
       bty = "n", col = "gray80", cex=1.1)
mtext("Body")
#dev.off()

#pdf(file="../figures/seasonHead.pdf", width = 8, height=4, family="sans")
seasonPlot(bodyPart="Head")
mtext("Head")
par(las=0)
mtext("Proportion Infected", side=2, line=3)
#dev.off()

#pdf(file="../figures/seasonSaliva.pdf", width = 8, height=4, family="sans")
par(las=1)
seasonPlot(bodyPart="Saliva")
mtext("Saliva")
dev.off()
```


# Statistical Analysis

Response Variable: Body, Head, and Saliva Infection Rates

Predictor Variables:

**Test 1**: Season & Land-Use

Based on the results of this, I want to know if this is in fact driven by microclimate:

**Test 2**: Microclimate (Temp and RH Variables)

Out of curiousity, also 

**Test 3**: Wing Length

And for a supplement, if we wanted to look at EIP rates:

**Test 4**: DPI

## Test 1: Season and Land-Use

I want to explore if season and land-use significantly influence infection dynamics. This will actually involve three tests (one each for body, head, saliva). I can then either a) test all DPI's at once with DPI as block factor (which may lead to strange results becuase of no 9 and 14 for october), or b) do each DPI seperately. I am currently going with the latter, which means I can only compare season for 21 dpi.

Using a Mixed-Effects Model with site as a random factor:

This [thread](https://stats.stackexchange.com/questions/134630/assessing-fit-of-binomial-glmer-in-r-with-only-categorical-predictors) has good info on how to assess accuracy of `glmer`.

So many examples (including some based on Bolker et al. 2009): http://glmm.wikidot.com/examples

```{r overdispersion function, echo=FALSE}
#this function is from https://ase.tufts.edu/gsc/gradresources/guidetomixedmodelsinr/mixed%20model%20guide.html

overdisp_fun <- function(model) {
    ## number of variance parameters in an n-by-n variance-covariance matrix
    vpars <- function(m) {
        nrow(m) * (nrow(m) + 1)/2
    }
    # The next two lines calculate the residual degrees of freedom
    model.df <- sum(sapply(VarCorr(model), vpars)) + length(fixef(model))
    rdf <- nrow(model.frame(model)) - model.df
    # extracts the Pearson residuals
    rp <- residuals(model, type = "pearson")
    Pearson.chisq <- sum(rp^2)
    prat <- Pearson.chisq/rdf
    # Generates a p-value. If less than 0.05, the data are overdispersed.
    pval <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
    c(chisq = Pearson.chisq, ratio = prat, rdf = rdf, p = pval)
}
```

I could make a function to do all this, but it is better to look at each individually.

### August 9 DPI

```{r, august 9 dpi Body infection, echo=FALSE}
#check out data 
# ggplot(data=august[august$DPI=="9",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Body)) +
#   ggtitle("August 9 dpi Body")
#pdf? We know is binomial becuase it is binary
#nbinom <- fitdistr(august$Body[august$DPI=="9"], "Negative Binomial")
#qqp(august$Body[august$DPI=="9"], "nbinom", size=nbinom$estimate[[1]], mu = nbinom$estimate[[2]])
mixModelAugBody9 <- lme4::glmer(Body~class + (1|site), 
                          data=august[august$DPI=="9",],
                          family=binomial)
#get a summary
summary(mixModelAugBody9)
#check significance
Anova(mixModelAugBody9) 
#check overdispersion
overdisp_fun(mixModelAugBody9) #it's okay!
plot(mixModelAugBody9)

```

```{r, august 9 dpi head infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="9",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Head)) +
#   ggtitle("August 9 dpi Head")
#model
mixModelAugHead9 <- lme4::glmer(Head~class + (1|site), 
                          data=august[august$DPI=="9",],
                          family=binomial)
#get a summary
summary(mixModelAugHead9)
#check significance
Anova(mixModelAugHead9) 
#check overdispersion
overdisp_fun(mixModelAugHead9) 
```

There was no saliva infections at 9 dpi, so not even running a test on that.

The above code runs a mixed model on body and head infection in August at 9 dpi with site as a random factor. There is **no significant effect of class on body or head infection in August trial 9 dpi**.

### August 14 DPI

```{r, august 14 dpi Body infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="14",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Body)) +
#   ggtitle("August 14 dpi Body")
#model
mixModelAugBody14 <- lme4::glmer(Body~class + (1|site), 
                          data=august[august$DPI=="14",],
                          family=binomial)
#get a summary
summary(mixModelAugBody14)
#check significance
Anova(mixModelAugBody14) 
#check overdispersion
overdisp_fun(mixModelAugBody14) 
```

This is approaching signficance, with Urban mosquitoes more likely to be infected (coef=0.888, p=0.1528).

```{r, august 14 dpi Head infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="14",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Head)) +
#   ggtitle("August 14 dpi Head")
#model
mixModelAugHead14 <- lme4::glmer(Head~class + (1|site), 
                          data=august[august$DPI=="14",],
                          family=binomial)
#get a summary
summary(mixModelAugHead14)
#check significance
Anova(mixModelAugHead14) 
#check overdispersion
overdisp_fun(mixModelAugHead14) 
```

As above, head infection is close to significance, with urban more likely than rural, but suburban and urban very similar.

```{r, august 14 dpi Saliva infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="14",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Saliva)) + 
#   ggtitle("August 14 dpi Saliva")
#model
mixModelAugSaliva14 <- lme4::glmer(Saliva~class + (1|site), 
                          data=august[august$DPI=="14",],
                          family=binomial)
#get a summary
summary(mixModelAugSaliva14)
#check significance
Anova(mixModelAugSaliva14) 
#check overdispersion
overdisp_fun(mixModelAugSaliva14) 
```

No difference in Saliva.

**At 9 and 14 dpi, there is no significant effect of class on the infection dynamics. Based on this, I am choosing to only focus on the 21 dpi for future statistical tests.**

### Season x Class 21 DPI

```{r seasonal 21 dpi Body infection}
#explore data
ggplot(data=seasons[seasons$DPI=="21",], aes(factor(class))) +
  geom_bar(stat="identity",aes(y=Body)) +
  facet_wrap(~block) + 
  ggtitle("21 dpi Body across Seasons")
#model #there was no interaction of class and block
mixModelseasonsBody21 <- lme4::glmer(Body~class + block + (1|site), 
                          data=seasons[seasons$DPI=="21",],
                          family=binomial(link="logit"))
#get a summary
summary(mixModelseasonsBody21)
#check significance
Anova(mixModelseasonsBody21, type=2) 
#check overdispersion
overdisp_fun(mixModelseasonsBody21) 
plot(mixModelseasonsBody21)

#Predict onto real data and compare
# test21 <- predict(mixModelseasonsBody21, data=seasons[seasons$DPI=="21",])
# plot(y=seasons[as.numeric(names(test21)), 'Body'], x=test21, 
#      col=c(colR,colS, colU)[as.numeric(seasons[as.numeric(names(test21)), 'class'])],
#      pch=c(15,17)[as.numeric(seasons[as.numeric(names(test21)), 'block'])],
#      xlab="Model Predictions",
#      ylab="Observed Values")
```

We find that class and block have a significant effect on Body infection at 21 days, but there is no interaction between the two.


```{r seasonal 21 dpi Head infection}
#explore data
ggplot(data=seasons[seasons$DPI=="21",], aes(factor(class))) +
  geom_bar(stat="identity",aes(y=Head)) +
  facet_wrap(~block) +
  ggtitle("21 dpi Head Across Seasons")
#model
mixModelseasonsHead21 <- lme4::glmer(Head~class + block + block*class + (1|site), 
                          data=seasons[seasons$DPI=="21",],
                          family=binomial(link="logit"))
#get a summary
summary(mixModelseasonsHead21)
#check significance
Anova(mixModelseasonsHead21) 
#check overdispersion
overdisp_fun(mixModelseasonsHead21) 
```

Again, there is a significant effect of class and block, but no interaction. Similar effects as with the body infections.

```{r seasonal 21 dpi Saliva infection, echo=FALSE}
#explore data
ggplot(data=seasons[seasons$DPI=="21",], aes(factor(class))) +
  geom_bar(stat="identity",aes(y=Saliva)) +
  facet_wrap(~block) + 
  ggtitle("21 dpi Saliva across Seasons")
#model
mixModelseasonsSaliva21 <- lme4::glmer(Saliva~class + block + block*class + (1|site), 
                          data=seasons[seasons$DPI=="21",],
                          family=binomial(link="logit"))
#get a summary
summary(mixModelseasonsSaliva21)
#check significance
Anova(mixModelseasonsSaliva21)
#check overdispersion
overdisp_fun(mixModelseasonsSaliva21) 
```

There is **no significant effect on saliva**. There is almost (p=0.052) an effect of block, but not quite.

## Test 2: Microclimate

Based on the results of Test 1, we only see a difference in infection at 21 dpi sampling time point, so this is all we will use in our microclimate tests.

### Load and Format Microclimate Data

```{r clean climate data, echo=FALSE, eval=T}
climate <- read.csv('../../data/microclimate/clean/2016TrialsAdult.csv')[,-1]
#toss out ridiculous levels
climate <- climate[climate$Temp<75,]
#format date
climate$Date <- strptime(climate$Date, format="%Y-%m-%d %H:%M:%S")
#draw out day
climate$Day <- as.Date(climate$Date)

# add tray id to climate data
trayID <- read.csv("../../data/microclimate/trayLoggerID.csv") #read in IDs
climate <- merge(climate, trayID, by="Pot_ID")

#fix duplicates for R1T1
climate <- unique(climate)

#U2T2 and U1T2 are missing data
range(climate[climate$Tray_ID=="U2T2", 'Date']) 
range(climate[climate$Tray_ID=="U1T2", 'Date']) 

#drop U2T2 becuase it only has data until August 5th
inds <- which(climate$Tray_ID=="U2T2")
climate <- climate[-inds,]
rm(inds)

#U2T4 wasn't working right, reporting temps above 40C in October
inds <- which(climate$Tray_ID=="U2T4")
climate <- climate[-inds,]
rm(inds)

#save cleaned climate for other analyses
#write.csv(climate, file='../../data/microclimate/clean/2016TrialsAdultCleaned.csv', row.names = F)
```

```{r investigate individual data logger data, eval=F, echo=F}
for (i in 1:length(levels(climate$Tray_ID))){
  tempID <- levels(climate$Tray_ID)[i]
  temp <- climate[climate$Tray_ID==tempID,]
  temp <- temp[order(temp$Day),]
  ggplot(data=temp, aes(factor(Day), y=Temp)) +
    #geom_point(aes(x=Day, y=Temp)) + 
    geom_boxplot() +
    ggtitle(tempID)
}
```


We need to correct these for the days when mosquitoes were actually collected, and the number of mosquitoes from each tray.

```{r load emergence data,echo=FALSE}
augEmerg <- read.csv("../../data/emergence/raw/AugustEmergence.csv")
augEmerg$block <- as.factor("summer")
octEmerg <- read.csv("../../data/emergence/raw/OctoberEmergence.csv")
octEmerg$block <- as.factor("fall")

allEmerg <- rbind(augEmerg, octEmerg)
```

```{r standardize and correct for emergence, echo=FALSE}
#filter out only days when infected mosquitoes were in the trays
octInf <- octEmerg %>%
  filter(Sex=="F") %>%
  filter((Site_Code %in% c("U3", "R3") & Day <= 21) |
           (Site_Code %in% c("U2", "U1", "S3") & Day <= 20) |
           (Site_Code %in% c("S1", "S2", "R1", "R2") & Day <= 24))

augInf <- augEmerg %>%
  filter(Sex=="F") %>%
    filter((Site_Code %in% c("U2", "U1", "S3", "R1") & Day <= 14) |
           (Site_Code %in% c("S1", "S2", "R2", "R3", "U3") & Day <= 17))
```

```{r process october climate, message=F, echo=FALSE}
detach("package:plyr", unload=TRUE)
octClim <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-09-26","%Y-%m-%d")) %>%
  #filter out appropriate days
  filter((Site_ID %in% c("U3", "R3") & Day <= "2016-10-21") |
           (Site_ID %in% c("U2", "U1", "S3") & Day <= "2016-10-20") |
           (Site_ID %in% c("S1", "S2", "R1", "R2") & Day <= "2016-10-24")) %>%
  dplyr::select(-Site_ID, -Pot_ID, -Class) %>%
  #get daily averages by Tray
  group_by(Tray_ID, Day) %>%
  summarise_each(funs(mean(., na.rm=T), min(., na.rm=T), max(., na.rm=T))) %>%
  #calculate DTR
  mutate(DTR=Temp_max-Temp_min) %>%
  #get overall average over study period per tray (average daily values)
  ungroup() %>%
  dplyr::select(-Day) %>%
  group_by(Tray_ID) %>%
  summarise_each(funs(mean))

#calculate hours above a set Tmax and below a set Tmin based on Mordecai et al min and max r0, min=16C, max= 31 C

#calculate percent of time above and below temperatures

octBelow16 <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-09-26","%Y-%m-%d")) %>%
  #filter out appropriate days
  filter((Site_ID %in% c("U3", "R3") & Day <= "2016-10-21") |
           (Site_ID %in% c("U2", "U1", "S3") & Day <= "2016-10-20") |
           (Site_ID %in% c("S1", "S2", "R1", "R2") & Day <= "2016-10-24")) %>%
  filter(Temp<16) %>%
  group_by(Tray_ID) %>%
  dplyr::summarise(Tcount=n()) %>%
  mutate(hoursBelow16=Tcount/6) %>%
  select(-Tcount)



octAbove31 <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-09-26","%Y-%m-%d")) %>%
  #filter out appropriate days
  filter((Site_ID %in% c("U3", "R3") & Day <= "2016-10-21") |
           (Site_ID %in% c("U2", "U1", "S3") & Day <= "2016-10-20") |
           (Site_ID %in% c("S1", "S2", "R1", "R2") & Day <= "2016-10-24")) %>%
  filter(Temp>31) %>%
  group_by(Tray_ID) %>%
  summarise(Tcount=n()) %>%
  mutate(hoursAbove31=Tcount/6) %>%
  select(-Tcount)


#merge climate variables together
octClim <- merge(octClim, octBelow16, by="Tray_ID", all.x=T)
octClim <- merge(octClim, octAbove31, by="Tray_ID", all.x=T)

#add 0s
octClim$hoursAbove31[is.na(octClim$hoursAbove31)] <- 0
octClim$hoursBelow16[is.na(octClim$hoursBelow16)] <- 0

##new method of weighting climate by expanded infection
octInfExp <- octInf[rep(seq.int(1,nrow(octInf)), octInf$Num_Emerge),]
test <- merge(octInfExp, octClim, by.x="Tray_Code", by.y="Tray_ID", all.x=T)

octEnvVar <- test %>%
  dplyr::select(-Tray_Code,-Site, -Tray, - Class, - Month, - Day, - Exp_Day, - Sex) %>%
  group_by(block,Site_Code) %>%
  summarise_each(funs(mean(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) 

  
rm(test) #clear unused temporary dataframe
```

```{r august climate formatting, message=F, echo=FALSE}
##repeat above for August
augClim <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-08-01","%Y-%m-%d")) %>%
    filter((Site_ID %in% c("U2", "U1", "S3", "R1") & Day <= "2016-08-14") |
           (Site_ID %in% c("S1", "S2", "R2", "R3", "U3") & Day <= "2016-08-17")) %>%
  dplyr::select(-Site_ID, -Pot_ID, -Class) %>%
  #get daily averages by Tray
  group_by(Tray_ID, Day) %>%
  summarise_each(funs(mean(., na.rm=T), min(., na.rm=T), max(., na.rm=T))) %>%
  #calculate DTR
  mutate(DTR=Temp_max-Temp_min) %>%
  #get overall average over study period per tray (average daily values)
  ungroup() %>%
  dplyr::select(-Day) %>%
  group_by(Tray_ID) %>%
  summarise_each(funs(mean))

#calculate hours above a set Tmax and below a set Tmin based on Mordecai et al min and max r0, min=16C, max= 31 C

#calculate number of hours above and below temperatures
#there are no hours below 16 in august
# augBelow16 <- climate %>%
#   dplyr::select(-Date) %>%
#   filter(Day >= as.Date("2016-08-01","%Y-%m-%d")) %>%
#     filter((Site_ID %in% c("U2", "U1", "S3", "R1") & Day <= "2016-08-14") |
#            (Site_ID %in% c("S1", "S2", "R2", "R3", "U3") & Day <= "2016-08-17")) %>%
#   filter(Temp<16) %>%
#   group_by(Tray_ID) %>%
#   summarise(Tcount=n()) %>%
#   mutate(hoursBelow16=Tcount/6) %>%
#   select(-Tcount)

augAbove31 <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-08-01","%Y-%m-%d")) %>%
  filter((Site_ID %in% c("U2", "U1", "S3", "R1") & Day <= "2016-08-14") |
           (Site_ID %in% c("S1", "S2", "R2", "R3", "U3") & Day <= "2016-08-17")) %>%
  filter(Temp>31) %>%
  group_by(Tray_ID) %>%
  dplyr::summarise(Tcount=n()) %>%
  mutate(hoursAbove31=Tcount/6) %>%
  select(-Tcount)


#merge climate variables together
augClim <- merge(augClim, augAbove31, by="Tray_ID", all.x=T)

#add 0s
augClim$hoursAbove31[is.na(augClim$hoursAbove31)] <- 0
augClim$hoursBelow16 <- 0

##new method of weighting climate by expanded infection
augInfExp <- augInf[rep(seq.int(1,nrow(augInf)), augInf$Num_Emerge),]
test <- merge(augInfExp, augClim, by.x="Tray_Code", by.y="Tray_ID", all.x=T)

augEnvVar <- test %>%
  dplyr::select(-Tray_Code,-Site, -Tray, - Class, - Month, - Day, - Exp_Day, - Sex) %>%
  group_by(block,Site_Code) %>%
  summarise_each(funs(mean(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) 

rm(test)

```

```{r, echo=FALSE}
#merge the summer and fall into one dataframe
oct$block <- as.factor("fall")
august$block <- as.factor("summer")
seasonInf <- merge(rbind(oct, august[august$DPI=="21",]), rbind(augEnvVar,octEnvVar), by.x=c("block", "site"), by.y=c("block", "Site_Code"))
```

This results in a dataframe `seasonInf` that has the infection status and environmental variables associated with each individual in both seasons.

### Stats

### Test 2b: Climate and Infection by Site

When plotting environmental variables against each other, I realized why it was so difficult for classification models to identify infected individuals.  This is becuase the climatic variables were grouped by site, so identical variables could be describing infected and non-infected individuals.  With this is in mind, it is actually quite remarkable that it was able to discren anything at all from the data, and gives me hope that if I consider infection at the site level, this will be more informative.

```{r create dataframe of site-aggregated infections}
seasonSite <- seasons %>%
  filter(DPI=="21") %>%
  dplyr::select(-Individual, -DPI) %>%
  dplyr::group_by(block, class, site) %>%
  summarise_each(funs(mean(.,na.rm=T)))

#group with temperature data
seasonInfSite <- merge(seasonSite, rbind(augEnvVar,octEnvVar), by.x=c("block", "site"), by.y=c("block", "Site_Code"))
```

Now for some visualization:

```{r}
envVarPlot("Body", dataset=seasonInfSite)
envVarPlot("Head", dataset=seasonInfSite)
envVarPlot("Saliva", dataset=seasonInfSite)
```

Correlation plots:

```{r}
line_fn <- function(data, mapping, ...){
  p <- ggplot(data = data, mapping = mapping) + 
    geom_point() + 
    geom_smooth(method=loess, fill="red", color="red", ...) +
    geom_smooth(method=lm, fill="blue", color="blue", ...)
  p
}
ggpairs(seasonInfSite, 8:ncol(seasonInfSite),lower = list(continuous = line_fn))
```

Now pair-wise plots of variables, based on some of the output of the GBM and glmnet from above:

```{r}
par(mfrow=c(3,3))
vars <- colnames(seasonInfSite)[-c(1:7)]
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[2])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[3])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[4])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[5])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[6])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[7])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[8])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[9])) +
  geom_point(aes(color=Body, shape=class, size=Body))
```


Using glmnet to make a regression:

```{r}
respV <- "Body"
predVs <- c("Temp_mean","RH_mean","Temp_min","RH_min", "Temp_max", "DTR", "hoursAbove31", "hoursBelow16")

hist(seasonInfSite$Body)

#create dataframe without NAs
myCols <- c(respV, predVs, "block")
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)
#modDF[,respV] <- as.factor(modDF[,respV])
#levels(modDF[,respV]) <- c("no", "yes")


#split into testing and training - Don't do because only have 18 values
# set.seed(8675309)
# inds <- createDataPartition(modDF[,respV], p=.7, list=F, times=1)
# train <- modDF[inds,]
# test <- modDF[-inds,]

##glmnet
glmControl <- trainControl(method='LOOCV', 
                           #number=17,
                           returnResamp='none',
                           preProcOptions = c("center", "corr", "scale")
                           )
#bodyPreds <- predVs[-c(4,2,7,8)]
bodyFx <- as.formula(Body~ Temp_mean*block + 0)
x <- model.matrix(bodyFx, modDF,
                  contrasts.arg = list(block=contrasts(modDF$block, contrasts=F))
                  )
set.seed(8675309)
glmModel <- train(x,
  #modDF[,c('Temp_mean','Temp_min','Temp_max', 'DTR', 'block')], 
                  modDF[, respV], 
                  method='glmnet',
                  trControl=glmControl)

plot(varImp(glmModel,scale=F))
glmModel$results
coef(glmModel$finalModel, glmModel$bestTune$lambda)

```

The best way to judge importance of the variables could be to drop out each and look at model performance.

First Run:
- Dropping Temp_min has no effect on performance
- Dropping RH_min improves performance
- Dropping Temp_max improves, but not as much as RH_min
- Dropping Hours above 31 improves performance (as much as RH_min)
- Dropping Hours below 16 greatly decreases performance

Decision (1): 
- Drop  RH_min from the model - RMSE of 15.94, R2 of 0.3955

Second Run:
- Dropping Temp_mean drops performance
- Dropping Temp_min improves performance(RMSE=0.1533)
- RH_mean has no impact
- Temp_max has no impact
- Dropping DTR improves performance (RMSE=0.1582)
- Droping Hours above 31 greatly improves performance (RMSE=15.06)
- Hours Below 16 decreases

Decions (2):
- Drop Hours Above 31 (RMSE=15.06, R2=0.4403)

Third Run:
- RH_mean improves performance (RMSE=0.1484)
- all the rest decrease performance

Decision (3): 
- Drop RH_mean (RMSE=0.1484, R2=0.428)
- Adding back HoursAbove31 decreases performance

Fourth Run
-

Final Model: Temp_mean, Temp_min, Temp_max, DTR (RMSE=0.1416, R2=0.4727)

Note that I have also tried adding in block as a covariate (both alone and an interaction), and it was always dropped.

#### Visualization of Important Variables

```{r}
par(mfrow=c(3,3))
ggplot(data=seasonInfSite, aes(x=Temp_mean, y=Temp_min)) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes(x=Temp_mean, y=hoursBelow16)) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes(x=Temp_mean, y=DTR)) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes(x=Temp_mean, y=Temp_max)) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes(x=DTR, y=hoursBelow16)) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes(x=Temp_max, y=DTR)) +
  geom_point(aes(color=Body, shape=class, size=Body)) #this is especially cool
ggplot(data=seasonInfSite, aes(x=Temp_min, y=DTR)) +
  geom_point(aes(color=Body, shape=class, size=Body))

ggplot(data=seasonInfSite, aes(x=Temp_mean, y=Body))+
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Body Infection")
```

```{r 3D Chart}
library(plotly)

plot_ly(seasonInfSite, x=~Temp_mean, y=~Temp_min, z=~Body, color=~class, colors=c(colRural, colSuburban, colUrban)) %>%
  add_markers()
```

Need a plot of temp_mean and body infection (scattler plots with SE bars)
```{r}
png(file="../figures/forMS/bodyInfxMeanTemp.png", width = 6, height=4, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_mean, y=Body))+
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Body Infection")+
  xlab("Mean Daily Temperature (C)")
dev.off()
```


```{r}
png(file="../figures/forMS/bodyInfxMinTemp.png", width = 6, height=3, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_min, y=Body))+
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Body Infection") +
  xlab("Minimum Daily Temperature (C)")
dev.off()
```

#### Head Infection Glmnet

```{r}
respV <- "Head"
predVs <- c("Temp_mean","RH_mean","Temp_min","RH_min", "Temp_max", "DTR", "hoursAbove31", "hoursBelow16")

hist(seasonInfSite$Head)

#create dataframe without NAs
myCols <- c(respV, predVs)
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)
#modDF[,respV] <- as.factor(modDF[,respV])
#levels(modDF[,respV]) <- c("no", "yes")


#split into testing and training - Don't do because only have 18 values
# set.seed(8675309)
# inds <- createDataPartition(modDF[,respV], p=.7, list=F, times=1)
# train <- modDF[inds,]
# test <- modDF[-inds,]

##glmnet
glmControl <- trainControl(method='LOOCV', 
                           #number=17,
                           returnResamp='none'
                           #preProcOptions = c("center", "corr", "scale")
                           )
set.seed(8675309)
glmModel <- train(modDF[, predVs[-c(3,4,6,8,7)]], modDF[, respV], 
                  method='glmnet',
                  trControl=glmControl)

plot(varImp(glmModel,scale=T))
glmModel$results
coef(glmModel$finalModel, glmModel$bestTune$lambda)
```

The initial model drops Temp_min, RH_min, DTR, and hoursBelow16. RMSE=0.15908

Now we can use stepwise regression to look further:

First Pass
- Temp_mean increases RMSE
- RH_mean increases RMSE
- Temp_max increases RMSE
- hoursAbove31 drops RMSE

Decision
- drop hoursabove31 (RMSE=0.1525, R2=0.4310)

Second Pass
- all variables increase RMSE when dropped

Final Model: Temp_max, Temp_mean, RH_mean (RMSE=0.1525, R2=0.4310)

```{r}
png(file="../figures/forMS/headInfxMaxTemp.png", width = 6, height=4, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_max, y=Head))+
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Head Infection")+
  xlab("Maximum Daily Temperature (C)")
dev.off()
```

#### Saliva Infection

I don't know if it necessarily worth it to consider saliva infection since there was no general trend found in the class and season model, but I will give it a shot.

```{r}
png(file="../figures/forMS/salivaInfxMaxTemp.png", width = 6, height=4, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_max, y=Saliva))+
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Saliva Infection")+
  xlab("Maximum Daily Temperature (C)")
dev.off()
```

```{r}
respV <- "Saliva"
predVs <- c("Temp_mean","RH_mean","Temp_min","RH_min", "Temp_max", "DTR", "hoursAbove31", "hoursBelow16")

hist(seasonInfSite$Saliva)

#create dataframe without NAs
myCols <- c(respV, predVs)
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)
#modDF[,respV] <- as.factor(modDF[,respV])
#levels(modDF[,respV]) <- c("no", "yes")


#split into testing and training - Don't do because only have 18 values
# set.seed(8675309)
# inds <- createDataPartition(modDF[,respV], p=.7, list=F, times=1)
# train <- modDF[inds,]
# test <- modDF[-inds,]

##glmnet
glmControl <- trainControl(method='LOOCV', 
                           #number=17,
                           returnResamp='none'
                           #preProcOptions = c("center", "corr", "scale")
                           )
set.seed(8675309)
glmModel <- train(modDF[, predVs[-c(3,4,6,8,7)]], modDF[, respV], 
                  method='glmnet',
                  trControl=glmControl)

plot(varImp(glmModel,scale=T))
glmModel$results
coef(glmModel$finalModel, glmModel$bestTune$lambda)
```

Glmnet drops four variables, leaving Temp_mean, RH_mean, Temp_max, and hoursAbove31. (RMSE=0.1620)

First run:
- Dropping tmax improves model (RMSE=0.1602)
- dropping hoursabove31 greatly improves model (RMSE=0.1525)

Decision: Drop hoursabove31

Second run: This is the best performing model

Final model: Temp_max, Temp_mean, RH_mean  (RMSE=0.1525, R2=0.4310)




### Test 3: Winglength

Because we have found a significant effect of class on body and head infection, but no significant effect of climate, we are wondering if it is indirectly through body size. That is, microclimate leads to different sized mosquitoes, and different size mosquitoes are more or less susceptible to infection. This requires two tests:

* a) the relationship between wing size and infection
* b) the relationship between climate and wing size

#### Test 3.a Wing Size and Infection

```{r}
par(mfrow=c(3,1))
ggplot(data=seasonInf, aes_string(x="Wing", y="Body")) +
  geom_point(aes(color=class)) +
  geom_smooth()
ggplot(data=seasonInf, aes_string(x="Wing", y="Head")) +
  geom_point(aes(color=class)) +
  geom_smooth()
ggplot(data=seasonInf, aes_string(x="Wing", y="Saliva")) +
  geom_point(aes(color=class)) +
  geom_smooth()
```

From these rough plots, it does seem like larger mosquitoes are less likely to have body or head infections than smaller. And, as above, there is really no trend in Saliva infections.

Now we try some tests:

```{r}
mixModelwingBody <- lme4::glmer(Body~Wing, 
                          data=seasonInf,
                          family=binomial(link="logit"))
plot(mixModelwingBody)
summary(mixModelwingBody)

glmWingBody <- glm(as.factor(Body)~Wing, 
                          data=seasonInf,
                          family=binomial(link="logit"))
summary(glmWingBody)
plot(glmWingBody)
```

#### Test 3.b Climate and Wing Size

I've actually decided to wait and do this for the whole experiment.

```{r}
envVarPlot("Wing")
```


Really seems like warmer sites (urban), had larger mosquitoes, and therefore lower infection of body and heads. And then, when it comes to Saliva, it really doesn't matter.


\newpage

# Deprecated
#### Visualization

```{r facet visualization function, echo=FALSE}
envVarPlot <- function(sample, dataset=seasonInf){
  
p1 <- ggplot(data=dataset, aes_string(x="Temp_mean", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p2 <- ggplot(data=dataset, aes_string(x="Temp_max", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p3 <- ggplot(data=dataset, aes_string(x="Temp_min", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p4 <- ggplot(data=dataset, aes_string(x="RH_mean", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p5 <- ggplot(data=dataset, aes_string(x="RH_max", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p6 <- ggplot(data=dataset, aes_string(x="RH_min", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p7 <- ggplot(data=dataset, aes_string(x="DTR", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p8 <- ggplot(data=dataset, aes_string(x="hoursAbove31", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth() +
  theme(legend.position="none")

p9 <- ggplot(data=dataset, aes_string(x="hoursBelow16", y=sample)) +
  geom_point(aes(color=class)) +
  geom_smooth()

plotAll <- grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8,p9,nrow=3)
return(plotAll)
}
```

```{r visualize all sample types, echo=FALSE}
envVarPlot("Body")
envVarPlot("Head")
envVarPlot("Saliva")
```

Based on the GBM models, several variables have arisen as important, so I am plotting them against each other to explore any clustering

```{r multivariate visualization}
ggplot(data=seasonInf, aes(x=Temp_mean, y=DTR)) +
  geom_point(aes(shape=factor(Body), color=class), size=4)

```

There doesn't seem to be much of an effect of any of them on saliva infection, but all the temperature variables seem to have a similar effect, and the RH variables an inverse (which makes sense). RH max is super weird because most of them have 100, so I will not use it in the glmer model.

We can also check out some collinearity and correlations.

```{r inspect correlation, echo=FALSE}
#envVars <- seasonInf[,10:ncol(seasonInf)]
#corrplot(cor(envVars))
#pairs(envVars)
line_fn <- function(data, mapping, ...){
  p <- ggplot(data = data, mapping = mapping) + 
    geom_point() + 
    geom_smooth(method=loess, fill="red", color="red", ...) +
    geom_smooth(method=lm, fill="blue", color="blue", ...)
  p
}
ggpairs(seasonInf, 10:ncol(seasonInf),lower = list(continuous = line_fn))
```

There are some variables that are highly correlated. 

#### GBM

Because the response is binary, I'm going to give it a shot using glmnet and GBM. Also, there is no longer a random effect of site because the environmental variables are aggregated by site.

```{r GBM, echo=FALSE}
respV <- "Body"
predVs <- c("Temp_mean","RH_mean","Temp_min","RH_min", "Temp_max", "DTR", "hoursAbove31", "hoursBelow16")

prop.table(table(seasonInf[,respV])) #need at least %15 infected for easier stats

#create dataframe without NAs
myCols <- c(respV, predVs)
modDF <- seasonInf %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)
#modDF[,respV] <- as.factor(modDF[,respV])
#levels(modDF[,respV]) <- c("no", "yes")


#split into testing and training
set.seed(8675309)
inds <- createDataPartition(modDF[,respV], p=.7, list=F, times=1)
train <- modDF[inds,]
test <- modDF[-inds,]

#set controls for testing different tuning parameters
# gbmControl <- trainControl(method='cv', returnResamp='none', summaryFunction = twoClassSummary, classProbs = TRUE, preProcOptions = c("center", "scale", "corr"))
# 
# gbmTune <- expand.grid(n.trees=c(10000, 20000), interaction.depth=c(1,2,3), shrinkage=c(0.1,0.01,0.005), n.minobsinnode=c(1))
# set.seed(8675309)
# gbmModel <- train(train[,predVs], (train[,respV]), 
#                   method='gbm', 
#                   trControl=gbmControl,  
#                   metric = "ROC",
#                   tuneGrid=gbmTune,
#                   verbose=F) 
#based on training from above
gbmModel <- gbm(Body~., 
                distribution="bernoulli",
                n.trees=20000,
                interaction.depth = 3, 
                shrinkage=0.01, 
                n.minobsinnode=1,
                bag.fraction=0.25,
                n.cores=4,
                data=train)
library(dplyr)

```

```{r}
summary(gbmModel)
plot(gbmModel)
gbmModel

#check performance
preds <- predict(object=gbmModel, test[,predVs], n.trees=20000)
aucGBM <- roc(test[,respV], preds)
aucGBM

```

The GBM performs not so great on Body with an AUC of `r print(aucGBM$auc)`.

The important variables are `r print(summary(gbmModel))`

```{r plot GBM variable importance}
library(gbm)
plot.gbm(gbmModel, i.var=1)
plot.gbm(gbmModel, i.var=2)
plot.gbm(gbmModel, i.var=3)
plot.gbm(gbmModel, i.var=4)
plot.gbm(gbmModel, i.var=5)
plot.gbm(gbmModel, i.var=6)
plot.gbm(gbmModel, i.var=7)
plot.gbm(gbmModel, i.var=8)
```


#### glmnet


```{r}
#create new controls and models
glmControl <- trainControl(method='cv', number=3, returnResamp='none', classProbs=T, preProcOptions = c("center", "corr", "scale")) #3 cd levels
set.seed(8675309)
glmModel <- train(train[, predVs], train[, respV], 
                  method='glmnet',  
                  metric = "Accuracy", 
                  trControl=glmControl)

plot(varImp(glmModel,scale=F))
glmModel$results

#check performance
preds <- predict(object=glmModel, test[,predVs], type='prob')
aucGLMnet <- roc(ifelse(test[,respV]=="yes",1,0), preds[[2]])
```

This performed slightly better than the `GBM`, with an AUC of `r aucGLMnet$auc`. The important variables are `Temp_mean`, `DTR`, `RH_mean`, `Temp_min`.

**Classification Summary**: Both models perform poorly, with an AUC of around 0.58-0.61 on the testing data. This could be due to the collinearity of the variables. Similar variables do arise as important, however, with `Temp_mean`, `DTR` and `RH_mean` coming up as especially important.


#### glm

We can try this out with a generalized linear model (note we don't need a mixed-model because we have no random effect of site).

```{r, eval=T}
#drop Tmax because it is rank deficient
set.seed(8675309)
logregModel <- train(train[, predVs], train[, respV], 
                  method='logreg',  
                  metric = "Accuracy", 
                  trControl=glmControl)


BodyEnv <- glm(Body~ 
                         scale(Temp_mean, center=T, scale=T) 
                       + scale(DTR, center=T, scale=T) 
                       + scale(RH_mean, center=T, scale=T) 
                        + scale(Temp_min, center=T, scale=T) 
                        + scale(RH_min, center=T, scale=T) 
                       #+ scale(Temp_max, center=T, scale=T)
                       # + scale(hoursAbove31, center=T, scale=T)
                       # + scale(hoursBelow16, center=T, scale=T) 
                          ,data=train,
                          family=binomial(link="logit"))

summary(BodyEnv) 
#plot(BodyEnv)

#check performance
preds <- predict(object=BodyEnv, test[,predVs], type='response')
aucGLM <- roc(test[,respV], preds)
aucGLM
```

The only variable that is even somewhat significant is mean RH(p=0.04 and mean Temp (0.05). The other variables are also highly correlated, which makes it difficult to see which is having the largest effect. This does perform about the same as the `GBM` and `glmnet` models, with an auc of `r aucGLM$auc`. It's AIC is `r AIC(BodyEnv)`

#### Model Selection using a priori variable selection

First, I will try to do model selection based on what variables the earlier lasso regression had chosen to keep.

```{r GLM with a priori variable selection}
BodyEnvMS <- glm(Body~ 
                         scale(Temp_mean, center=T, scale=T) 
                       + scale(DTR, center=T, scale=T) 
                       + scale(RH_mean, center=T, scale=T) 
                       + scale(Temp_min, center=T, scale=T), 
                       #+ scale(RH_min, center=T, scale=T) 
                       #+ scale(Temp_max, center=T, scale=T)
                       #+ scale(hoursAbove31, center=T, scale=T)
                       #+ scale(hoursBelow16, center=T, scale=T), 
                          data=train,
                          family=binomial(link="logit"))

summary(BodyEnvMS)
plot(BodyEnvMS)

#check performance
preds <- predict(object=BodyEnvMS, test[,predVs], type='response')
aucGLMMS <- roc(test[,respV], preds)
AIC(BodyEnvMS)
```


The BIC value of this is `r BIC(BodyEnvMS)` compare to `r BIC(BodyEnv)` for the one without variable selection.  It's AUC value is `r print(aucGLMMS$auc)`. This really isn't much different than the other one with all of the variables. The AUC and AIC values are the same, and the BIC value only decreases because of parsimony (i.e. it penalizes having more variables).


## Summary Plots by Site

```{r plot by site function}
sitePlot <- function(summTable, dpi, bodyPart){
  cols <- c(1:3,grep(bodyPart, colnames(summTable)))
temp <- summTable[summTable$DPI==dpi,cols]
colnames(temp)[4:6] <- c("mean", "sd", "se")
  barCenters <- barplot(temp$mean, 
          col=c(colRural, colSuburban, colUrban)[temp$class],
          names.arg=temp$site,
          ylim=c(0,max(temp$mean+0.2)),
          main = paste0(bodyPart, " Infection (", dpi, "dpi)")
          )
  #add se bars
  segments(barCenters, temp$mean - temp$se , barCenters,
         temp$mean + temp$se, lwd = 1.5)
  
  arrows(barCenters, temp$mean - temp$se , barCenters,
         temp$mean + temp$se, lwd = 1.5, 
         angle = 90,
       code = 3, length = 0.05)
}

```

```{r plot:body, eval=FALSE, echo=FALSE}
par(mfrow=c(2,2))
sitePlot(summTable=augustSumm, dpi="9", bodyPart = "Body")
sitePlot(summTable=augustSumm, dpi="14", bodyPart = "Body")
sitePlot(summTable=augustSumm, dpi="21", bodyPart = "Body")

sitePlot(summTable=octSumm, dpi="21", bodyPart="Body")
mtext("October")
```

```{r plot:head, eval=FALSE, echo=FALSE}
par(mfrow=c(2,2))
sitePlot(summTable=augustSumm, dpi="9", bodyPart = "Head")
sitePlot(summTable=augustSumm, dpi="14", bodyPart = "Head")
sitePlot(summTable=augustSumm, dpi="21", bodyPart = "Head")

sitePlot(summTable=octSumm, dpi="21", bodyPart="Head")
mtext("October")
```

```{r plot:saliva,eval=FALSE, echo=FALSE}
sitePlot(summTable=augustSumm, dpi="9", bodyPart = "Saliva")
sitePlot(summTable=augustSumm, dpi="14", bodyPart = "Saliva")
sitePlot(summTable=augustSumm, dpi="21", bodyPart = "Saliva")

sitePlot(summTable=octSumm, dpi="21", bodyPart="Saliva")
mtext("October")
```

## Plotting them beside each other

```{r beside plot function}
besidePlot <- function(summTable, bodyPart, byclass=F){
  if (byclass==T){
    cols <- c(1:2,grep(bodyPart, colnames(summTable)))
  } else cols <- c(1:3,grep(bodyPart, colnames(summTable)))
  tempLarge <- summTable[,cols]
  colnames(tempLarge)[(ncol(tempLarge)-2):ncol(tempLarge)] <- c("mean", "sd", "se")
  if (byclass==F){
  tempMean <- tempLarge %>%
    select(-sd,-se, -class) %>%
    spread(DPI, mean) %>%
    select(-site)
  } else tempMean <- tempLarge %>%
    select(-sd,-se) %>%
    spread( DPI, mean) %>%
    select(-class)
  if (byclass==T){
    rownames(tempMean) <- levels(summTable$class)
    } else rownames(tempMean) <- levels(summTable$site)
  tempMean <- t(as.matrix(tempMean))
  #colors
  if (byclass==T){
    colvec <- c(rep(colRural,3), rep(colSuburban,3), 
                            rep(colUrban,3))
  } else colvec <- c(rep(colRural,9), rep(colSuburban,9), 
                            rep(colUrban,9))
  #plot
  barCenters <- barplot(tempMean, 
                      beside=T,
                      col=colvec,
                      density = c(10,40,NA),
                      names.arg=colnames(tempMean),
                      ylim=c(0,0.80),
                      main = paste0("Dengue ", bodyPart," Infections"),
                      ylab = "Percent Infected"
                      )

    if (byclass==F){
  tempSE <- tempLarge %>%
    select(-sd,-mean,-class) %>%
    spread( DPI, se) %>%
    select(-site)
  } else   tempSE <- tempLarge %>%
    select(-sd,-mean) %>%
    spread( DPI, se) %>%
    select(-class)
  
  tempSE <- t(tempSE)
  
  #add se bars
  segments(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE, lwd = 1.5)
  
  arrows(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE,
         lwd = 1.5, 
         angle = 90,
         code = 3, length = 0.03)
  
  legend("topright", legend=c("9 dpi","14 dpi", "21 dpi"), density = c(10,40,NA),
       bty = "n", col = "gray80")
}
```

## August Plots by DPI

Note there are none of these for October becuase we only did 21 dpi.

```{r barplot:besideBody, eval=T, echo=FALSE}
#pdf(file="../figures/augustBody.pdf", width = 8, height=6, family="sans")
besidePlot(summTable=augustSumm, bodyPart="Body")
#dev.off()
```

```{r barplot:besideHead aug, eval=T, echo=FALSE}
#pdf(file="../figures/augustHead.pdf", width = 8, height=6, family="sans")
besidePlot(summTable=augustSumm, bodyPart="Head")
#dev.off()
```

```{r barplot:besideSaliva, eval=T, echo=FALSE}
#pdf(file="../figures/augustSaliva.pdf", width = 8, height=6, family="sans")
besidePlot(summTable=augustSumm, bodyPart="Saliva")
#dev.off()
```



## Plots by Class

```{r beside barplot for october, echo=FALSE}
besidePlotOct <- function(summTable, bodyPart, byclass=F){
  if (byclass==T){
    cols <- c(1,2,grep(bodyPart, colnames(summTable)))
  } else cols <- c(1:3,grep(bodyPart, colnames(summTable)))
  tempLarge <- summTable[,cols]
  colnames(tempLarge)[(ncol(tempLarge)-2):ncol(tempLarge)] <- c("mean", "sd", "se")
  if (byclass==F){
  tempMean <- tempLarge %>%
    select(-sd,-se, -class) %>%
    spread( DPI, mean) %>%
    select(-site)
  } else tempMean <- tempLarge %>%
    select(-sd,-se, -class, -DPI)
  if (byclass==T){
    rownames(tempMean) <- levels(summTable$class)
    } else rownames(tempMean) <- levels(summTable$site)
  tempMean <- t(as.matrix(tempMean))
  #colors
  if (byclass==T){
    colvec <- c(rep(colRural,1), rep(colSuburban,1), 
                            rep(colUrban,1))
  } else colvec <- c(rep(colRural,3), rep(colSuburban,3), 
                            rep(colUrban,3))
  #plot
  barCenters <- barplot(tempMean, 
                      beside=T,
                      col=colvec,
                      density = c(NA),
                      names.arg=colnames(tempMean),
                      ylim=c(0,0.80),
                      main = paste0("Dengue ", bodyPart," Infections"),
                      ylab = "Percent Infected"
                      )

    if (byclass==F){
  tempSE <- tempLarge %>%
    select(-sd,-mean,-class) %>%
    spread( DPI, se) %>%
    select(-site)
  } else   tempSE <- tempLarge %>%
    select(-sd,-mean) %>%
    spread( DPI, se) %>%
    select(-class)
  
  tempSE <- t(tempSE)
  
  #add se bars
  segments(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE, lwd = 1.5)
  
  arrows(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE,
         lwd = 1.5, 
         angle = 90,
         code = 3, length = 0.03)
  
  #legend("topright", legend=c("9 dpi","14 dpi", "21 dpi"), density = c(10,40,NA),
       #bty = "n", col = "gray80")
}

```

```{r format by class, eval=T}
augustclassSumm <- august%>%
  #drop individual
  select(-Individual, -site) %>%
  group_by(DPI, class) %>%
  summarise_each(funs(mean(.,na.rm=T),sd(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) %>%
  ungroup()

#print(xtable(augustclassSumm), type="html")
augustclassSumm

octclassSumm <- oct %>%
  select(-Individual, -site) %>%
  group_by(DPI, class) %>%
  summarise_each(funs(mean(.,na.rm=T),sd(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) %>%
  ungroup()

#print(xtable(octclassSumm), type="html")
octclassSumm
```

```{r plot by class, eval=FALSE, echo=FALSE}
pdf(file="../figures/forMS/augustHeadClass.pdf", width = 8, height=6, family="sans")
besidePlot(summTable=augustclassSumm, bodyPart="Head", byclass=T)
dev.off()

pdf(file="../figures/forMS/augustBodyClass.pdf", width = 8, height=6, family="sans")
besidePlot(summTable=augustclassSumm, bodyPart="Body", byclass=T)
dev.off()

pdf(file="../figures/forMS/augustSalivaClass.pdf", width = 8, height=6, family="sans")
besidePlot(summTable=augustclassSumm, bodyPart="Saliva", byclass=T)
dev.off()

pdf(file="../figures/forMS/octoberHeadClass.pdf", width = 8, height=6, family="sans")
besidePlotOct(summTable=octclassSumm, bodyPart="Head", byclass=T)
dev.off()

pdf(file="../figures/forMS/octoberBodyClass.pdf", width = 8, height=6, family="sans")
besidePlotOct(summTable=octclassSumm, bodyPart="Body", byclass=T)
dev.off()

pdf(file="../figures/forMS/octoberSalivaClass.pdf", width = 8, height=6, family="sans")
besidePlotOct(summTable=octclassSumm, bodyPart="Saliva", byclass=T)
dev.off()

```


```{r summary table}
augustSumm <- august %>%
  #drop individual
  select(-Individual) %>%
  group_by(DPI, site, class) %>%
  summarise_each(funs(mean(.,na.rm=T),sd(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) %>%
  ungroup()

#print(xtable(augustSumm), type="html")
augustSumm

octSumm <- oct %>%
  #drop individual
  select(-Individual) %>%
  group_by(DPI, site, class) %>%
  summarise_each(funs(mean(.,na.rm=T),sd(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) %>%
  ungroup()

#print(xtable(octSumm), type="html")
octSumm
```

```{r efficiency plot function, eval=FALSE, include=F}
effPlot <- function(rawTable){
  #format data
  tempLarge <- rawTable %>%
    filter(DPI=="21") %>%
    group_by(site,class) %>%
    mutate(bodyEff=mean(Body, na.rm=T))%>%
    ungroup() %>%
    filter(Body==1) %>%
    group_by(site,class) %>%
    mutate(headEff=mean(Head, na.rm=T))%>%
    ungroup() %>%
    filter(Head==1)%>%
    group_by(site,class) %>%
    mutate(salEff=mean(Saliva, na.rm=T))%>%
    select(site, class, bodyEff, headEff, salEff) %>%
    ungroup()
  tempLarge <- unique(tempLarge)
  #get mean and se
  temp <- tempLarge %>%
    select(-site) %>%
    group_by(class) %>%
    summarise_each(funs(mean(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) %>%
    ungroup()
  
  tempMean <- as.matrix(temp[,2:4])
  rownames(tempMean) <- levels(temp$class)
  tempMean <- t(tempMean)
 
  colvec <- c(rep(colRural,3), rep(colSuburban,3), 
                            rep(colUrban,3))
  #plot
  barCenters <- barplot(tempMean, 
                      beside=T,
                      col=colvec,
                      density = c(20,60,NA),
                      names.arg=colnames(tempMean),
                      ylim=c(0,1),
                      ylab = "Relative Efficiency"
                      )

  tempSE <- as.matrix(temp[,5:7])
  
  tempSE <- t(tempSE)
  
  #add se bars
  segments(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE, lwd = 1.5)
  
  arrows(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE,
         lwd = 1.5, 
         angle = 90,
         code = 3, length = 0.03)
  
  #legend("topright", legend=c("9 dpi","14 dpi", "21 dpi"), density = c(10,40,NA),
       #bty = "n", col = "gray80")
}
```

```{r plot effiency, eval=FALSE, include=F}
pdf(file="../figures/augEff.pdf", width = 8, height=4, family="sans")
effPlot(rawTable=august)
dev.off()

pdf(file="../figures/octEff.pdf", width = 8, height=4, family="sans")
effPlot(rawTable=oct)
dev.off()
```

