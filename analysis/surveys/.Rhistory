library(adaptivetau)
#x<-c(S,V,I,J,Pathogen)
transrates = function(x, par, t){
#par=c(p, b, w, delta, theta, dur, K)
#x=c(S,V,I,J,P)
# if popn stochastically fluctuates above carrying capacity, then birth rates would be negative!
# so set birth rates to be given by density dependent function if pop less than k and zero otherwise
b0 <-(1-(x[1]+x[2]+x[3]+x[4])/par[7])
b <- ifelse(b0<0,0,b0)
rates=c(
#host birth
#((1-par[1])*par[2]*(x[1]+x[2])*(1-(x[1]+x[2]+x[3]+x[4])/par[7])),
(1-par[1])*par[2]*(x[1]+x[2])*b,
#host natural death
par[3]*x[1],
#vacc birth
par[1]*par[2]*(x[1]+x[2])*b,
#vacc death
par[3]*x[2],
#I host death
par[3]*x[3],
#J host death
par[3]*x[4],
#pathogen death
par[3]*x[5],
#J disease induced mortality
((1-par[6])/par[5])*x[4],
#1st phage adsorption S->I
par[4]*x[1]*x[5],
#transtion I-> J
(par[6]/par[5])*x[3],
#additional adsorption events
par[4]*x[3]*x[5]
)
return(rates)
}
#From Levin et al 1977 Am Nat ##in hours##
theta=0.5 #30 minutes
alpha=98 # burst size
delta=6.24*10^-8
b=0.738 #56 min doubling time
#Transition matrix#
## Each row is a model compartment and each column corresponds to transitions in the transrates function.
## Note that the death of an infected individual causes a -1 for the J infected class, and a +alpha for the pathogen class. This is the release of infectious spores from an infected host.
#class order SVIJP
M=matrix(c(1,0,0,0,0, #host birth
-1,0,0,0,0, #host natural death
0,1,0,0,0, #vac birth
0,-1,0,0,0, #vac death
0,0,-1,0,0, #I host natural death
0,0,0,-1,0, #J natural death
0,0,0,0,-1,  #pathogen death
0,0,0,-1, alpha, #J disease induced death
-1,0,1,0,-1, #1st phage adsorption S->I
0,0,-1,1,0, #transtion I-> J
0,0,0,0,-1 #additional adsorption events
),nrow=5)
# Flexible model parameters
p=0.
w=0.25
dur=0.0025
K=10^8
#par=c(p, b, w, delta, theta, dur)
stoch.params<-c(p, b, w, delta, theta, dur, K)
#Initial conditions of state variables
Y0=c(10^5,0,0,0,10^5)
tmax=200
stoch=ssa.adaptivetau(Y0, M , transrates, stoch.params, tmax )
pulsed.simulation=function(pulse,window=24,reps, newxstart, stoch.params=c(0, b, w, delta, theta, dur, K),matrix=M, rates=transrates){
#prep for loop
class<-c('S','V','I','J','P')
newtime.series<-c()
tmax=window+10
for(i in 1:reps){
as.data.frame(ssa.adaptivetau(newxstart, matrix , rates, stoch.params, tmax ))->pulse.out
#determine the last time point calculated in simulation
approx(pulse.out[,1],pulse.out[,2])->S.out
ifelse(S.out$x < window,TRUE,FALSE)->masked
#row number of last time point to include in this vaccination interval.
sum(masked)->end
#make time continuous
approx(pulse.out[,1],pulse.out[,3])->V.out
approx(pulse.out[,1],pulse.out[,4])->I.out
approx(pulse.out[,1],pulse.out[,5])->J.out
approx(pulse.out[,1],pulse.out[,6])->P.out
#Population sizes at end of window
S.out$y[end]->S
V.out$y[end]->V
I.out$y[end]->I
J.out$y[end]->J
P.out$y[end]->P
#Calculate how many cells to move from S to V class
Sp<- pulse*S
#Create new vector of starting population
S.new<- ceiling(S-Sp)
V.new<- floor(V +Sp)
I.new<- round(I,digits=0)
J.new<- round(J,digits=0)
P.new<- round(P,digits=0)
newxstart<-c(S.new, V.new, I.new, J.new, P.new)
unlist(newxstart)->newxstart
names(newxstart)<-class
#make time continuous
cbind(time=S.out$x, S=S.out$y,V=V.out$y,I=I.out$y,J=J.out$y,P=P.out$y)-> total.sim
total.sim[c(1:end),c(2:6)]->trim.sim
total.sim[1:end,1]->trim.time
#add time from this pulse to last pulse
length(newtime.series[,1])->last.time
newtime.series[last.time,1]-> addtime
#first time through loop this will be zero
if(is.null(addtime)){addtime=0}
pulsed.time <- trim.time + addtime
cbind(pulsed.time,trim.sim)-> trim
newtime.series<-rbind(newtime.series, trim)
}
return(newtime.series)
}
p.list<- seq(0.6,.7, by=.05)
sims <- 100
frac.extinct <- c()
for (j in p.list){
#pulsed<-p.list[j]
extinct <- 0
for (i in 1:sims){
#Prep for simulation
newxstart<-c(S=29472497,V=0,I=16858742,J=37652,P=2333608)
stoch.params<-c(0, b, w, delta, theta, dur, K)
#need to run through loop with pulses#
pulsed.simulation(pulse=j, window=.5, reps=1000,newxstart=newxstart)-> stoch
#determines if phage was extinct at end of simulation, if extinct add 1 to extinct
extinct <- extinct + ifelse(tail(stoch[,6],1)==0,1,0)
}
#over all simulations, number of phage going extinct
ex<-(extinct/sims)
frac.extinct <- c(frac.extinct, ex)
}
cbind(p.list, frac.extinct)
quit()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
setwd("~/")
setwd("~/Dropbox/UGA/Research/Murdock/urbanDengue/analysis/surveys")
habitats <- read.csv("../../data/larvalSurveys/clean/larvalHabitat.csv")
habitats$Date <- as.Date(as.character(habitats$Date))
habitats$Positive <- ifelse(habitats$Larvae.Pupae=="None",0,1)
ids <- read.csv("../../data/larvalSurveys/clean/Identifications.csv")
library(caret)
pcaDat <- habitats %>%
select(Positive, type=Type..factor., date=Date, area=Surface.Area..cm2., depth=Depth..cm., canCover=Canopy.Cover, turb=Turbidity, temp=Temp)
#check out data
for (col in 1:ncol(pcaDat)) {
hist(pcaDat[,col])
}
pcaDat <- na.omit(pcaDat) #omit NAs
pcaScale <- scale(pcaDat[,4:ncol(pcaDat)], center=T, scale=T) #center and scale
cor(pcaScale)
summary(pcaDat)
library(PerformanceAnalytics)
library("FactoMineR")
library(lubridate)
habPCA <- PCA(pcaScale, scale.unit = T, graph=T)
fviz_pca_ind(habPCA, label="none", habillage=pcaDat$Positive, addEllipses=T, ellipse.level=0.95)
library(factoextra)
fviz_screeplot(habPCA, ncp=10)
library(rgl)
plot3d(habPCA$ind$coord, col=pcaDat$Positive+1) #need x11 installed
plot(habPCA)
View(pcaDat)
habitats2 <- habitats %>%
mutate(class = case_when(
Site %in% c("R1", "R2", "R3") ~ "rural",
Site %in% c("S1", "S2", "S3") ~ "suburban",
Site %in% c("U1", "U2", "U3") ~ "urban"
))
habitats2 <- habitats %>%
mutate(class = case_when(
.$Site %in% c("R1", "R2", "R3") ~ "rural",
.$Site %in% c("S1", "S2", "S3") ~ "suburban",
.$Site %in% c("U1", "U2", "U3") ~ "urban"
))
View(habitats2)
habitats <- habitats %>%
mutate(class = case_when(
.$Site %in% c("R1", "R2", "R3") ~ "rural",
.$Site %in% c("S1", "S2", "S3") ~ "suburban",
.$Site %in% c("U1", "U2", "U3") ~ "urban"
))
pcaDat <- habitats %>%
select(Positive, type=Type..factor., date=Date, class, area=Surface.Area..cm2., depth=Depth..cm., canCover=Canopy.Cover, turb=Turbidity, temp=Temp)
pcaDat <- na.omit(pcaDat) #omit NAs
pcaScale <- scale(pcaDat[,4:ncol(pcaDat)], center=T, scale=T) #center and scale
habPCA <- PCA(pcaScale, scale.unit = T, graph=T)
pcaScale <- scale(pcaDat[,5:ncol(pcaDat)], center=T, scale=T) #center and scale
cor(pcaScale)
habPCA <- PCA(pcaScale, scale.unit = T, graph=T)
fviz_pca_ind(habPCA, label="none", habillage=pcaDat$class, addEllipses=T, ellipse.level=0.95)
View(habitats)
pcaDat <- habitats %>%
select(Positive, type=Type..factor., date=Date, class, area=Surface.Area..cm2., depth=Depth..cm., canCover=Canopy.Cover, turb=Turbidity, temp=Temp)
View(pcaDat)
View(habitats)
pcaDat <- habitats %>%
filter(Site != "U3" & Type..factor.!=pond)
select(Positive, type=Type..factor., date=Date, class, area=Surface.Area..cm2., depth=Depth..cm., canCover=Canopy.Cover, turb=Turbidity, temp=Temp)
pcaDat <- habitats %>%
filter(Site != "U3" & Type..factor.!="pond") %>%
select(Positive, type=Type..factor., date=Date, class, area=Surface.Area..cm2., depth=Depth..cm., canCover=Canopy.Cover, turb=Turbidity, temp=Temp)
View(pcaDat)
pcaDat <- na.omit(pcaDat) #omit NAs
pcaScale <- scale(pcaDat[,5:ncol(pcaDat)], center=T, scale=T) #center and scale
habPCA <- PCA(pcaScale, scale.unit = T, graph=T)
fviz_pca_ind(habPCA, label="none", habillage=pcaDat$Positive, addEllipses=T, ellipse.level=0.95)
fviz_pca_ind(habPCA, label="none", habillage=pcaDat$type, addEllipses=T, ellipse.level=0.95)
fviz_pca_ind(habPCA, label="none", habillage=as.factor(month(pcaDat$date)), addEllipses=T, ellipse.level=0.95)
fviz_pca_ind(habPCA, label="none", habillage=pcaDat$class, addEllipses=T, ellipse.level=0.95)
plot3d(habPCA$ind$coord, col=pcaDat$Positive+1) #need x11 installed
plot3d(habPCA$ind$coord, col=as.numeric(pcaDat$class)) #need x11 installed
as.numeric((pcaDat$class))
plot3d(habPCA$ind$coord, col=as.numeric(as.factor((pcaDat$class))) #need x11 installed
)
plot3d(habPCA$ind$coord, col=as.numeric(as.factor((pcaDat$class)))) #need x11 installed
habPCA
habPCA$var$contrib
plot3d(habPCA$ind$coord, col=pcaDat$type)
plot3d(habPCA$ind$coord, col=as.numeric(pcaDat$type))
habPCA$ind$coord
plot(x=habPCA$ind$coord[,1], y=habPCA$ind$coord[,3])
plot(x=habPCA$ind$coord[,2], y=habPCA$ind$coord[,3])
plot(x=habPCA$ind$coord[,2], y=habPCA$ind$coord[,3], pch=20, col=as.numeric(as.factor((pcaDat$class))))
