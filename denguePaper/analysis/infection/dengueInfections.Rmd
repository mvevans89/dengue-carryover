---
title: "Dengue Infections 2016"
author: "Michelle Evans"
date: '`r format(Sys.Date())`'
output:
  html_document: 
    theme: flatly
    keep_md: true
  
---

This document is for the analysis of both the August and October Trials of Infections of the Dengue Microclimate project in Athens, GA in 2016.

```{r packages and setup}
library(knitr)
knitr::opts_chunk$set(cache=TRUE)
knitr::opts_chunk$set(message=FALSE)
knitr::opts_chunk$set(warning=FALSE)
```

# Lab Notebook of Tried Things


* Infection Statistical Analysis *
- GBM on individual level infection: did not work becuase the climate data was aggregated to the site level (Early April 2017)
- glmnet for variable selection with site level infection rates: this worked fairly well, but I also noticed strong differences across block (season). This inspired me to then try a mixed-model which could have block as a random effect (mid-April 2017)
- lmer model: informed by variable selection from glmnet. It is informed in that all of the variables are extremely correlated, but mean_temp came out as important. And I think it makes the most sense to focus on that for now. (April 20 2017)
- added efficiency analysis (May 2017)
- incorporated the effect of body size into analysis (May 2017)


```{r}
library(xtable)
library(tidyr)
library(ggplot2) 
library(lme4) #mixed models
library(car)
library(MASS)
library(gridExtra) #for facet grids later
library(gbm)
library(caret)
library(pROC)
library(corrplot)
library(glmnet)
library(GGally)
library(dplyr)
library(ggthemes)
library(piecewiseSEM)
```

```{r}
colR <- colRural <- "dodgerblue"
colS <- colSuburban <- "gray80"
colU <- colUrban <- "maroon"
```

# Exploratory Visualizations

## Comparing Seasons in Plots

```{r}
formatData <- function(month){
  #' format infection data
  #' @params month (ie. "august")
  #' @returns dataframe of properly formatted data
  #adjust wingLength
  monthDf <- read.csv(paste0("../../data/infections/raw/", month,"Dengue.csv"))
  #convert wingLength and drop extra columns
  monthDf$Wing <- monthDf$WingLength*monthDf$conversion..mm.bar.
  monthDf <- select(monthDf, -WingLength, -conversion..mm.bar.)
  
  #dpi as factor
  monthDf$DPI <- as.factor(monthDf$DPI)
  
  #add in class and site
  monthDf$site <- as.factor(substr(as.character(monthDf$Individual), 1, 2))
  monthDf$class <- NULL
  for (i in 1:nrow(monthDf)){
    if (substr(monthDf$site[i], 1,1)=="R"){
    monthDf$class[i] <- "Rural"
    } else if (substr(monthDf$site[i], 1,1)=="S"){
    monthDf$class[i] <- "Suburban"
    } else if (substr(monthDf$site[i], 1,1)=="U"){
    monthDf$class[i] <- "Urban"
    }
  }
  monthDf$class <- as.factor(monthDf$class)
  
  #convert Y and N to 1 and 0 for statistics
  levels(monthDf$Body) <- c("NA", 0, 1)
  monthDf$Body <- as.numeric(as.character(monthDf$Body))
  levels(monthDf$Saliva) <- c("NA", 0, 1)
  monthDf$Saliva <- as.numeric(as.character(monthDf$Saliva))
  # august had no contaminated heads, so different corrections
  if (month=="august"){
    levels(monthDf$Head) <- c(0, 1)
  } else levels(monthDf$Head) <- c("NA",0, 1)
  monthDf$Head <- as.numeric(as.character(monthDf$Head))
  
  ##Fix false negatievs
  #adjust so that if saliva is positive, so is head
  #ddjust so that is head is positive, so is body
  monthDf$Head[monthDf$Saliva>0] <- 1
  monthDf$Body[monthDf$Head>0] <- 1
  
  return(monthDf)
}

august <- formatData("august")
oct <- formatData("october")
```

```{r}
seasons <- rbind(august,oct)
seasons$block <- as.factor(c(rep("summer", nrow(august)), rep("fall", nrow(oct))))

seasonSumm <- seasons %>%
  filter(DPI==21) %>%
  #drop individual
  select(-Individual, -site, -Wing, -DPI) %>%
  group_by(block, class) %>%
  summarise_each(funs(mean(.,na.rm=T),sd(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) %>%
  ungroup()
```

```{r}
seasonPlot <- function(bodyPart, summTable=seasonSumm){
  cols <- c(1,2,grep(bodyPart, colnames(summTable)))
  tempLarge <- summTable[,cols]
  colnames(tempLarge)[3:5] <- c("mean", "sd", "se")
    
  tempMean <- tempLarge %>%
    select(-sd,-se) %>%
    spread(block, mean) %>%
    select(-class)
  
  #put summer before fall
  tempMean <- tempMean[,c(2,1)]

  
  rownames(tempMean) <- levels(tempLarge$class)
  tempMean <- t(as.matrix(tempMean))
  
  colvec <- c(rep(colRural,2), rep(colSuburban,2), 
                            rep(colUrban,2))
  
  barCenters <- barplot(tempMean, 
                      beside=T,
                      col=colvec,
                      density = c(40,NA),
                      names.arg=colnames(tempMean),
                      ylim=c(0,0.80)
                      )
  
  tempSE <- tempLarge %>%
    select(-sd,-mean) %>%
    spread(block, se) %>%
    select(-class)
  
   #put summer before fall
  tempSE <- tempSE[,c(2,1)]
  
   tempSE <- t(tempSE)
  
  #add se bars
  segments(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE, lwd = 1.5)
  
  arrows(barCenters, tempMean - tempSE , barCenters,
         tempMean + tempSE,
         lwd = 1.5, 
         angle = 90,
         code = 3, length = 0.03)
  
  #legend("topright", legend=c("Summer", "Fall"), density = c(40,NA),
       #bty = "n", col = "gray80")
}
```


```{r seasonal plots, eval=F, echo=FALSE}
#pdf(file="../figures/forMS/seasonInfections.pdf", width = 4, height=6, family="sans")
png(file="../figures/forMS/seasonInfections.png", width = 4, height=6, units="in", res=500, family="sans")
par(mfrow=c(3,1), las=1, par(mar=c(5.1,6.1,4.1,2.1)))
#pdf(file="../figures/seasonBody.pdf", width = 8, height=4, family="sans")
seasonPlot(bodyPart="Body")
par(xpd=T)
legend(x=7.5, y=1.0, legend=c("Summer", "Fall"), density = c(40,NA),
       bty = "n", col = "gray80", cex=1.1)
mtext("Body")
#dev.off()

#pdf(file="../figures/seasonHead.pdf", width = 8, height=4, family="sans")
seasonPlot(bodyPart="Head")
mtext("Head")
par(las=0)
mtext("Proportion Infected", side=2, line=3)
#dev.off()

#pdf(file="../figures/seasonSaliva.pdf", width = 8, height=4, family="sans")
par(las=1)
seasonPlot(bodyPart="Saliva")
mtext("Saliva")
dev.off()
```


# Statistical Analysis

Response Variable: Body, Head, and Saliva Infection Rates

Predictor Variables:

**Test 1**: Season & Land-Use

Based on the results of this, I want to know if this is in fact driven by microclimate:

**Test 2**: Microclimate (Temp and RH Variables)

Out of curiousity, also 

**Test 3**: Wing Length

And for a supplement, if we wanted to look at EIP rates:

**Test 4**: DPI

## Test 1: Season and Land-Use

I want to explore if season and land-use significantly influence infection dynamics. This will actually involve three tests (one each for body, head, saliva). I can then either a) test all DPI's at once with DPI as block factor (which may lead to strange results becuase of no 9 and 14 for october), or b) do each DPI seperately. I am currently going with the latter, which means I can only compare season for 21 dpi.

Using a Mixed-Effects Model with site as a random factor:

This [thread](https://stats.stackexchange.com/questions/134630/assessing-fit-of-binomial-glmer-in-r-with-only-categorical-predictors) has good info on how to assess accuracy of `glmer`.

So many examples (including some based on Bolker et al. 2009): http://glmm.wikidot.com/examples

```{r overdispersion function, echo=FALSE}
#this function is from https://ase.tufts.edu/gsc/gradresources/guidetomixedmodelsinr/mixed%20model%20guide.html

overdisp_fun <- function(model) {
    ## number of variance parameters in an n-by-n variance-covariance matrix
    vpars <- function(m) {
        nrow(m) * (nrow(m) + 1)/2
    }
    # The next two lines calculate the residual degrees of freedom
    model.df <- sum(sapply(VarCorr(model), vpars)) + length(fixef(model))
    rdf <- nrow(model.frame(model)) - model.df
    # extracts the Pearson residuals
    rp <- residuals(model, type = "pearson")
    Pearson.chisq <- sum(rp^2)
    prat <- Pearson.chisq/rdf
    # Generates a p-value. If less than 0.05, the data are overdispersed.
    pval <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
    c(chisq = Pearson.chisq, ratio = prat, rdf = rdf, p = pval)
}
```

I could make a function to do all this, but it is better to look at each individually.

### August 9 DPI

```{r, august 9 dpi Body infection, echo=FALSE}
#check out data 
# ggplot(data=august[august$DPI=="9",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Body)) +
#   ggtitle("August 9 dpi Body")
#pdf? We know is binomial becuase it is binary
#nbinom <- fitdistr(august$Body[august$DPI=="9"], "Negative Binomial")
#qqp(august$Body[august$DPI=="9"], "nbinom", size=nbinom$estimate[[1]], mu = nbinom$estimate[[2]])
mixModelAugBody9 <- lme4::glmer(Body~class + (1|site), 
                          data=august[august$DPI=="9",],
                          family=binomial)
#get a summary
summary(mixModelAugBody9)
#check significance
Anova(mixModelAugBody9) 
#check overdispersion
overdisp_fun(mixModelAugBody9) #it's okay!
plot(mixModelAugBody9)

```

```{r, august 9 dpi head infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="9",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Head)) +
#   ggtitle("August 9 dpi Head")
#model
mixModelAugHead9 <- lme4::glmer(Head~class + (1|site), 
                          data=august[august$DPI=="9",],
                          family=binomial)
#get a summary
summary(mixModelAugHead9)
#check significance
Anova(mixModelAugHead9) 
#check overdispersion
overdisp_fun(mixModelAugHead9) 
```

There was no saliva infections at 9 dpi, so not even running a test on that.

The above code runs a mixed model on body and head infection in August at 9 dpi with site as a random factor. There is **no significant effect of class on body or head infection in August trial 9 dpi**.

### August 14 DPI

```{r, august 14 dpi Body infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="14",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Body)) +
#   ggtitle("August 14 dpi Body")
#model
mixModelAugBody14 <- lme4::glmer(Body~class + (1|site), 
                          data=august[august$DPI=="14",],
                          family=binomial)
#get a summary
summary(mixModelAugBody14)
#check significance
Anova(mixModelAugBody14) 
#check overdispersion
overdisp_fun(mixModelAugBody14) 
```

This is approaching signficance, with Urban mosquitoes more likely to be infected (coef=0.888, p=0.1528).

```{r, august 14 dpi Head infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="14",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Head)) +
#   ggtitle("August 14 dpi Head")
#model
mixModelAugHead14 <- lme4::glmer(Head~class + (1|site), 
                          data=august[august$DPI=="14",],
                          family=binomial)
#get a summary
summary(mixModelAugHead14)
#check significance
Anova(mixModelAugHead14) 
#check overdispersion
overdisp_fun(mixModelAugHead14) 
```

As above, head infection is close to significance, with urban more likely than rural, but suburban and urban very similar.

```{r, august 14 dpi Saliva infection, echo=FALSE}
#explore data
# ggplot(data=august[august$DPI=="14",], aes(factor(class))) +
#   geom_bar(stat="identity",aes(y=Saliva)) + 
#   ggtitle("August 14 dpi Saliva")
#model
mixModelAugSaliva14 <- lme4::glmer(Saliva~class + (1|site), 
                          data=august[august$DPI=="14",],
                          family=binomial)
#get a summary
summary(mixModelAugSaliva14)
#check significance
Anova(mixModelAugSaliva14) 
#check overdispersion
overdisp_fun(mixModelAugSaliva14) 
```

No difference in Saliva.

**At 9 and 14 dpi, there is no significant effect of class on the infection dynamics. Based on this, I am choosing to only focus on the 21 dpi for future statistical tests.**

### Season x Class 21 DPI

```{r seasonal 21 dpi Body infection}
#explore data
ggplot(data=seasons[seasons$DPI=="21",], aes(factor(class))) +
  geom_bar(stat="identity",aes(y=Body)) +
  facet_wrap(~block) + 
  ggtitle("21 dpi Body across Seasons")
#model #there was no interaction of class and block
mixModelseasonsBody21 <- lme4::glmer(Body~class + block + (1|site), 
                          data=seasons[seasons$DPI=="21",],
                          family=binomial(link="logit"))
#get a summary
summary(mixModelseasonsBody21)
#check significance
Anova(mixModelseasonsBody21, type=2) 
#check overdispersion
overdisp_fun(mixModelseasonsBody21) 
plot(mixModelseasonsBody21)

#Predict onto real data and compare
# test21 <- predict(mixModelseasonsBody21, data=seasons[seasons$DPI=="21",])
# plot(y=seasons[as.numeric(names(test21)), 'Body'], x=test21, 
#      col=c(colR,colS, colU)[as.numeric(seasons[as.numeric(names(test21)), 'class'])],
#      pch=c(15,17)[as.numeric(seasons[as.numeric(names(test21)), 'block'])],
#      xlab="Model Predictions",
#      ylab="Observed Values")
```

We find that class and block have a significant effect on Body infection at 21 days, but there is no interaction between the two.


```{r seasonal 21 dpi Head infection}
#explore data
ggplot(data=seasons[seasons$DPI=="21",], aes(factor(class))) +
  geom_bar(stat="identity",aes(y=Head)) +
  facet_wrap(~block) +
  ggtitle("21 dpi Head Across Seasons")
#model
mixModelseasonsHead21 <- lme4::glmer(Head~class + block + block*class + (1|site), 
                          data=seasons[seasons$DPI=="21",],
                          family=binomial(link="logit"))
#get a summary
summary(mixModelseasonsHead21)
#check significance
Anova(mixModelseasonsHead21) 
#check overdispersion
overdisp_fun(mixModelseasonsHead21) 
```

Again, there is a significant effect of class and block, but no interaction. Similar effects as with the body infections.

```{r seasonal 21 dpi Saliva infection, echo=FALSE}
#explore data
ggplot(data=seasons[seasons$DPI=="21",], aes(factor(class))) +
  geom_bar(stat="identity",aes(y=Saliva)) +
  facet_wrap(~block) + 
  ggtitle("21 dpi Saliva across Seasons")
#model
mixModelseasonsSaliva21 <- lme4::glmer(Saliva~class + block + block*class + (1|site), 
                          data=seasons[seasons$DPI=="21",],
                          family=binomial(link="logit"))
#get a summary
summary(mixModelseasonsSaliva21)
#check significance
Anova(mixModelseasonsSaliva21)
#check overdispersion
overdisp_fun(mixModelseasonsSaliva21) 
```

There is **no significant effect on saliva**. There is almost (p=0.052) an effect of block, but not quite.

## Test 2: Microclimate

Based on the results of Test 1, we only see a difference in infection at 21 dpi sampling time point, so this is all we will use in our microclimate tests.

### Load and Format Microclimate Data

```{r clean climate data, echo=FALSE, eval=T}
climate <- read.csv('../../data/microclimate/clean/2016TrialsAdult.csv')[,-1]
#toss out ridiculous levels
climate <- climate[climate$Temp<75,]
#format date
climate$Date <- strptime(climate$Date, format="%Y-%m-%d %H:%M:%S")
#draw out day
climate$Day <- as.Date(climate$Date)

# add tray id to climate data
trayID <- read.csv("../../data/microclimate/trayLoggerID.csv") #read in IDs
climate <- merge(climate, trayID, by="Pot_ID")

#fix duplicates for R1T1
climate <- unique(climate)

#U2T2 and U1T2 are missing data
range(climate[climate$Tray_ID=="U2T2", 'Date']) 
range(climate[climate$Tray_ID=="U1T2", 'Date']) 

#drop U2T2 becuase it only has data until August 5th
inds <- which(climate$Tray_ID=="U2T2")
climate <- climate[-inds,]
rm(inds)

#U2T4 wasn't working right, reporting temps above 40C in October
inds <- which(climate$Tray_ID=="U2T4")
climate <- climate[-inds,]
rm(inds)

#save cleaned climate for other analyses
#write.csv(climate, file='../../data/microclimate/clean/2016TrialsAdultCleaned.csv', row.names = F)
```

```{r investigate individual data logger data, eval=F, echo=F}
for (i in 1:length(levels(climate$Tray_ID))){
  tempID <- levels(climate$Tray_ID)[i]
  temp <- climate[climate$Tray_ID==tempID,]
  temp <- temp[order(temp$Day),]
  ggplot(data=temp, aes(factor(Day), y=Temp)) +
    #geom_point(aes(x=Day, y=Temp)) + 
    geom_boxplot() +
    ggtitle(tempID)
}
```


We need to correct these for the days when mosquitoes were actually collected, and the number of mosquitoes from each tray.

```{r load emergence data,echo=FALSE}
augEmerg <- read.csv("../../data/emergence/raw/AugustEmergence.csv")
augEmerg$block <- as.factor("summer")
octEmerg <- read.csv("../../data/emergence/raw/OctoberEmergence.csv")
octEmerg$block <- as.factor("fall")

allEmerg <- rbind(augEmerg, octEmerg)
```

```{r standardize and correct for emergence, echo=FALSE}
#filter out only days when infected mosquitoes were in the trays
octInf <- octEmerg %>%
  filter(Sex=="F") %>%
  filter((Site_Code %in% c("U3", "R3") & Day <= 21) |
           (Site_Code %in% c("U2", "U1", "S3") & Day <= 20) |
           (Site_Code %in% c("S1", "S2", "R1", "R2") & Day <= 24))

augInf <- augEmerg %>%
  filter(Sex=="F") %>%
    filter((Site_Code %in% c("U2", "U1", "S3", "R1") & Day <= 14) |
           (Site_Code %in% c("S1", "S2", "R2", "R3", "U3") & Day <= 17))
```

```{r process october climate, message=F, echo=FALSE}
detach("package:plyr", unload=TRUE)
octClim <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-09-26","%Y-%m-%d")) %>%
  #filter out appropriate days
  filter((Site_ID %in% c("U3", "R3") & Day <= "2016-10-21") |
           (Site_ID %in% c("U2", "U1", "S3") & Day <= "2016-10-20") |
           (Site_ID %in% c("S1", "S2", "R1", "R2") & Day <= "2016-10-24")) %>%
  dplyr::select(-Site_ID, -Pot_ID, -Class) %>%
  #get daily averages by Tray
  group_by(Tray_ID, Day) %>%
  summarise_each(funs(mean(., na.rm=T), min(., na.rm=T), max(., na.rm=T))) %>%
  #calculate DTR
  mutate(DTR=Temp_max-Temp_min) %>%
  #get overall average over study period per tray (average daily values)
  ungroup() %>%
  dplyr::select(-Day) %>%
  group_by(Tray_ID) %>%
  summarise_each(funs(mean))

#calculate hours above a set Tmax and below a set Tmin based on Mordecai et al min and max r0, min=16C, max= 31 C

#calculate percent of time above and below temperatures

octBelow16 <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-09-26","%Y-%m-%d")) %>%
  #filter out appropriate days
  filter((Site_ID %in% c("U3", "R3") & Day <= "2016-10-21") |
           (Site_ID %in% c("U2", "U1", "S3") & Day <= "2016-10-20") |
           (Site_ID %in% c("S1", "S2", "R1", "R2") & Day <= "2016-10-24")) %>%
  filter(Temp<16) %>%
  group_by(Tray_ID) %>%
  dplyr::summarise(Tcount=n()) %>%
  mutate(hoursBelow16=Tcount/6) %>%
  select(-Tcount)



octAbove31 <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-09-26","%Y-%m-%d")) %>%
  #filter out appropriate days
  filter((Site_ID %in% c("U3", "R3") & Day <= "2016-10-21") |
           (Site_ID %in% c("U2", "U1", "S3") & Day <= "2016-10-20") |
           (Site_ID %in% c("S1", "S2", "R1", "R2") & Day <= "2016-10-24")) %>%
  filter(Temp>31) %>%
  group_by(Tray_ID) %>%
  summarise(Tcount=n()) %>%
  mutate(hoursAbove31=Tcount/6) %>%
  select(-Tcount)


#merge climate variables together
octClim <- merge(octClim, octBelow16, by="Tray_ID", all.x=T)
octClim <- merge(octClim, octAbove31, by="Tray_ID", all.x=T)

#add 0s
octClim$hoursAbove31[is.na(octClim$hoursAbove31)] <- 0
octClim$hoursBelow16[is.na(octClim$hoursBelow16)] <- 0

##new method of weighting climate by expanded infection
octInfExp <- octInf[rep(seq.int(1,nrow(octInf)), octInf$Num_Emerge),]
test <- merge(octInfExp, octClim, by.x="Tray_Code", by.y="Tray_ID", all.x=T)

octEnvVar <- test %>%
  dplyr::select(-Tray_Code,-Site, -Tray, - Class, - Month, - Day, - Exp_Day, - Sex, -Num_Emerge) %>%
  group_by(block,Site_Code) %>%
  summarise_each(funs(mean(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) 

  
rm(test) #clear unused temporary dataframe
```

```{r august climate formatting, message=F, echo=FALSE}
##repeat above for August
augClim <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-08-01","%Y-%m-%d")) %>%
    filter((Site_ID %in% c("U2", "U1", "S3", "R1") & Day <= "2016-08-14") |
           (Site_ID %in% c("S1", "S2", "R2", "R3", "U3") & Day <= "2016-08-17")) %>%
  dplyr::select(-Site_ID, -Pot_ID, -Class) %>%
  #get daily averages by Tray
  group_by(Tray_ID, Day) %>%
  summarise_each(funs(mean(., na.rm=T), min(., na.rm=T), max(., na.rm=T))) %>%
  #calculate DTR
  mutate(DTR=Temp_max-Temp_min) %>%
  #get overall average over study period per tray (average daily values)
  ungroup() %>%
  dplyr::select(-Day) %>%
  group_by(Tray_ID) %>%
  summarise_each(funs(mean))

#calculate hours above a set Tmax and below a set Tmin based on Mordecai et al min and max r0, min=16C, max= 31 C

#calculate number of hours above and below temperatures
#there are no hours below 16 in august
# augBelow16 <- climate %>%
#   dplyr::select(-Date) %>%
#   filter(Day >= as.Date("2016-08-01","%Y-%m-%d")) %>%
#     filter((Site_ID %in% c("U2", "U1", "S3", "R1") & Day <= "2016-08-14") |
#            (Site_ID %in% c("S1", "S2", "R2", "R3", "U3") & Day <= "2016-08-17")) %>%
#   filter(Temp<16) %>%
#   group_by(Tray_ID) %>%
#   summarise(Tcount=n()) %>%
#   mutate(hoursBelow16=Tcount/6) %>%
#   select(-Tcount)

augAbove31 <- climate %>%
  dplyr::select(-Date) %>%
  filter(Day >= as.Date("2016-08-01","%Y-%m-%d")) %>%
  filter((Site_ID %in% c("U2", "U1", "S3", "R1") & Day <= "2016-08-14") |
           (Site_ID %in% c("S1", "S2", "R2", "R3", "U3") & Day <= "2016-08-17")) %>%
  filter(Temp>31) %>%
  group_by(Tray_ID) %>%
  dplyr::summarise(Tcount=n()) %>%
  mutate(hoursAbove31=Tcount/6) %>%
  select(-Tcount)


#merge climate variables together
augClim <- merge(augClim, augAbove31, by="Tray_ID", all.x=T)

#add 0s
augClim$hoursAbove31[is.na(augClim$hoursAbove31)] <- 0
augClim$hoursBelow16 <- 0

##new method of weighting climate by expanded infection
augInfExp <- augInf[rep(seq.int(1,nrow(augInf)), augInf$Num_Emerge),]
test <- merge(augInfExp, augClim, by.x="Tray_Code", by.y="Tray_ID", all.x=T)

augEnvVar <- test %>%
  dplyr::select(-Tray_Code,-Site, -Tray, - Class, - Month, - Day, - Exp_Day, - Sex, -Num_Emerge) %>%
  group_by(block,Site_Code) %>%
  summarise_each(funs(mean(.,na.rm=T),se=(sd(., na.rm=T)/sqrt(n())))) 

rm(test)

```

```{r, echo=FALSE}
#merge the summer and fall into one dataframe
oct$block <- as.factor("fall")
august$block <- as.factor("summer")
seasonInf <- merge(rbind(oct, august[august$DPI=="21",]), rbind(augEnvVar,octEnvVar), by.x=c("block", "site"), by.y=c("block", "Site_Code"))
```

This results in a dataframe `seasonInf` that has the infection status and environmental variables associated with each individual in both seasons.

### Stats

### Test 2b: Climate and Infection by Site

When plotting environmental variables against each other, I realized why it was so difficult for classification models to identify infected individuals.  This is becuase the climatic variables were grouped by site, so identical variables could be describing infected and non-infected individuals.  With this is in mind, it is actually quite remarkable that it was able to discren anything at all from the data, and gives me hope that if I consider infection at the site level, this will be more informative.

```{r create dataframe of site-aggregated infections}
seasonSite <- seasons %>%
  filter(DPI=="21") %>%
  dplyr::select(-Individual, -DPI, Wing) %>%
  dplyr::group_by(block, class, site) %>%
  summarise_each(funs(mean(.,na.rm=T), se=(sd(., na.rm=T)/sqrt(n()))))

#group with temperature data
seasonInfSite <- merge(seasonSite, rbind(augEnvVar,octEnvVar), by.x=c("block", "site"), by.y=c("block", "Site_Code"))
```

Now for some visualization:

Correlation plots:

```{r}
line_fn <- function(data, mapping, ...){
  p <- ggplot(data = data, mapping = mapping) + 
    geom_point() + 
    geom_smooth(method=loess, fill="red", color="red", ...) +
    geom_smooth(method=lm, fill="blue", color="blue", ...)
  p
}
ggpairs(seasonInfSite, 10:18,lower = list(continuous = line_fn))
```

Now pair-wise plots of variables, based on some of the output of the GBM and glmnet from above:

```{r}
par(mfrow=c(3,3))
vars <- colnames(seasonInfSite)[8:16]
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[2])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[3])) +
  geom_point(aes(color=Body_mean, shape=class, size=Body_mean))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[4])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[5])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[6])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[7])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[8])) +
  geom_point(aes(color=Body, shape=class, size=Body))
ggplot(data=seasonInfSite, aes_string(x=vars[1], y=vars[9])) +
  geom_point(aes(color=Body, shape=class, size=Body))
```


Using glmnet to make a regression:

```{r}
respV <- "Body_mean"
predVs <- c("Temp_mean_mean","RH_mean_mean","Temp_min_mean","RH_min_mean", "Temp_max_mean", "DTR_mean", "hoursAbove31_mean", "hoursBelow16_mean")

hist(seasonInfSite$Body)

#create dataframe without NAs
myCols <- c(respV, predVs, "block")
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)
#modDF[,respV] <- as.factor(modDF[,respV])
#levels(modDF[,respV]) <- c("no", "yes")


#split into testing and training - Don't do because only have 18 values
# set.seed(8675309)
# inds <- createDataPartition(modDF[,respV], p=.7, list=F, times=1)
# train <- modDF[inds,]
# test <- modDF[-inds,]

##glmnet
glmControl <- trainControl(method='LOOCV', 
                           #number=17,
                           returnResamp='none',
                           preProcOptions = c("center", "corr", "scale")
                           )
bodyPreds <- predVs[-c(4,2,7,8)]

set.seed(8675309)
glmModel <- train(modDF[,predVs], 
                  modDF[, respV], 
                  method='glmnet',
                  trControl=glmControl)

plot(varImp(glmModel,scale=F))
glmModel$results
coef(glmModel$finalModel, glmModel$bestTune$lambda)
```

The best way to judge importance of the variables could be to drop out each and look at model performance.

First Run:
- Dropping Temp_min has no effect on performance
- Dropping RH_min improves performance
- Dropping Temp_max improves, but not as much as RH_min
- Dropping Hours above 31 improves performance (as much as RH_min)
- Dropping Hours below 16 greatly decreases performance

Decision (1): 
- Drop  RH_min from the model - RMSE of 15.94, R2 of 0.3955

Second Run:
- Dropping Temp_mean drops performance
- Dropping Temp_min improves performance(RMSE=0.1533)
- RH_mean has no impact
- Temp_max has no impact
- Dropping DTR improves performance (RMSE=0.1582)
- Droping Hours above 31 greatly improves performance (RMSE=15.06)
- Hours Below 16 decreases

Decions (2):
- Drop Hours Above 31 (RMSE=15.06, R2=0.4403)

Third Run:
- RH_mean improves performance (RMSE=0.1484)
- all the rest decrease performance

Decision (3): 
- Drop RH_mean (RMSE=0.1484, R2=0.428)
- Adding back HoursAbove31 decreases performance

Fourth Run
-

Final Model: Temp_mean, Temp_min, Temp_max, DTR (RMSE=0.1416, R2=0.4727)

Note that I have also tried adding in block as a covariate (both alone and an interaction), and it was always dropped.

**Second Statistical Test: Just a plain old lmer**

```{r}
respV <- "Body_mean"
predVs <- c("Temp_mean_mean","RH_mean_mean","Temp_min_mean","RH_min_mean", "Temp_max_mean", "DTR_mean", "hoursAbove31_mean", "hoursBelow16_mean")

#create dataframe without NAs
myCols <- c(respV, predVs, "block")
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)

lmerMod2 <- lmer(Body_mean~ Temp_mean_mean+Temp_min_mean + (1|block), data=modDF)
lmerMod3 <- lmer(Body_mean~ Temp_mean_mean*Temp_min_mean + (1|block), data=modDF)
lmerMod4 <- lmer(Body_mean~ Temp_mean_mean + (1|block), data=modDF)
lmerMod5 <- lmer(Body_mean~ Temp_mean_mean*Temp_min_mean+Temp_max_mean + (1|block), data=modDF)
lmerMod6 <- lmer(Body_mean~ Temp_mean_mean*Temp_min_mean*Temp_max_mean + (1|block), data=modDF)
lmerMod7 <- lmer(Body_mean~ Temp_min_mean + (1|block), data=modDF)
lmerMod8 <- lmer(Body_mean~ Temp_max_mean + (1|block), data=modDF) #intercept error
lmerMod9 <- lmer(Body_mean~ Temp_mean_mean + (Temp_mean_mean|block), data=modDF)

piecewiseSEM::rsquared(list( lmerMod4)) #lmerMod4 is the best

MuMIn::r.squaredGLMM(lmerMod4)
summary(lmerMod10)
Anova(lmerMod4)
plot(lmerMod4)

finalBody <- lmerMod4

#check predictive R2
preds <- predict(lmerMod4)
plot(preds, modDF$Body_mean)
abline(a=0, b=1)
cor(preds, modDF$Body_mean)
```

Based on this, I think I will choose to use an lmer. This is reasonable because the relationship does seem to be linear, especially once the block is set as a random effect.

The final model was chosen based on maximizing the $r^2$, which in this case also minimized AIC value. It includes mean temperature and block as a random factor.

#### Visualization of Important Variables

```{r}
png(file="../figures/forMS/bodyInfxMeanTemp.png", width = 6, height=4, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_mean_mean, y=Body_mean))+
  geom_errorbar(aes(ymin=Body_mean-Body_se, ymax=Body_mean+Body_se), color="gray20", width=0.1) +
  #geom_errorbarh(aes(xmin=Temp_mean_mean-Temp_mean_se, xmax=Temp_mean_mean+Temp_mean_se, y=Body_mean),color="gray20", height=0.05) + #not enough error to see
  geom_point(aes(color=class, shape=block), size=4.5) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Body Infection")+
  xlab("Mean Daily Temperature (C)")
dev.off()
```


```{r, eval=F}
png(file="../figures/forMS/bodyInfxMinTemp.png", width = 6, height=3, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_min_mean, y=Body_mean))+
    geom_errorbar(aes(ymin=Body_mean-Body_se, ymax=Body_mean+Body_se), color="gray20", width=0.1) +
  geom_errorbarh(aes(xmin=Temp_min_mean-Temp_min_se, xmax=Temp_min_mean+Temp_min_se), color="gray20", height=0.05) +
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Body Infection") +
  xlab("Minimum Daily Temperature (C)")
dev.off()
```

```{r, eval=F}
png(file="../figures/forMS/bodyInfxMaxTemp.png", width = 6, height=3, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_max_mean, y=Body_mean))+
    geom_errorbar(aes(ymin=Body_mean-Body_se, ymax=Body_mean+Body_se), color="gray20", width=0.1) +
  geom_errorbarh(aes(xmin=Temp_max_mean-Temp_max_se, xmax=Temp_max_mean+Temp_max_se), color="gray20", height=0.05) +
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Body Infection") +
  xlab("Maximum Daily Temperature (C)")
dev.off()
```


#### Head Infection Glmnet

```{r}
respV <- "Head"
predVs <- c("Temp_mean","RH_mean","Temp_min","RH_min", "Temp_max", "DTR", "hoursAbove31", "hoursBelow16")

hist(seasonInfSite$Head)

#create dataframe without NAs
myCols <- c(respV, predVs)
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)
#modDF[,respV] <- as.factor(modDF[,respV])
#levels(modDF[,respV]) <- c("no", "yes")


#split into testing and training - Don't do because only have 18 values
# set.seed(8675309)
# inds <- createDataPartition(modDF[,respV], p=.7, list=F, times=1)
# train <- modDF[inds,]
# test <- modDF[-inds,]

##glmnet
glmControl <- trainControl(method='LOOCV', 
                           #number=17,
                           returnResamp='none'
                           #preProcOptions = c("center", "corr", "scale")
                           )
set.seed(8675309)
glmModel <- train(modDF[, predVs[-c(3,4,6,8,7)]], modDF[, respV], 
                  method='glmnet',
                  trControl=glmControl)

plot(varImp(glmModel,scale=T))
glmModel$results
coef(glmModel$finalModel, glmModel$bestTune$lambda)
```

The initial model drops Temp_min, RH_min, DTR, and hoursBelow16. RMSE=0.15908

Now we can use stepwise regression to look further:

First Pass
- Temp_mean increases RMSE
- RH_mean increases RMSE
- Temp_max increases RMSE
- hoursAbove31 drops RMSE

Decision
- drop hoursabove31 (RMSE=0.1525, R2=0.4310)

Second Pass
- all variables increase RMSE when dropped

Final Model: Temp_max, Temp_mean, RH_mean (RMSE=0.1525, R2=0.4310)

** Second step:lmer**

For the lmer, I am only looking at one temp variable becuase they are all so correlated. I will explore variables with those combined with mean RH.

```{r}
respV <- "Head_mean"
predVs <- c("Temp_mean_mean","RH_mean_mean","Temp_min_mean","RH_min_mean", "Temp_max_mean", "DTR_mean", "hoursAbove31_mean", "hoursBelow16_mean")

#create dataframe without NAs
myCols <- c(respV, predVs, "block")
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)

lmerMod1 <- lmer(Head_mean~ Temp_max_mean + (1|block), data=modDF) #intercept error
lmerMod2 <- lmer(Head_mean~ Temp_mean_mean + (1|block), data=modDF) #highest R2
lmerMod3 <- lmer(Head_mean~ RH_mean_mean + (1|block), data=modDF)
lmerMod4 <- lmer(Head_mean~ Temp_mean_mean*RH_mean_mean+ (1|block), data=modDF) #lowest AIC
lmerMod5 <- lmer(Head_mean~ Temp_max_mean*RH_mean_mean+ (1|block), data=modDF)

piecewiseSEM::rsquared(list(lmerMod2, lmerMod3, lmerMod4, lmerMod5)) 

MuMIn::r.squaredGLMM(lmerMod2)
summary(lmerMod2)
Anova(lmerMod2)
plot(lmerMod2)

finalHead <- lmerMod2

#check predictive R2
preds <- predict(finalHead)
plot(preds, modDF$Head_mean)
abline(a=0, b=1)
cor(preds, modDF$Head_mean)
```

Chose the final model based on the best fit (marginal $R^2$). It includes mean temperature and block as a random effect.

```{r}
png(file="../figures/forMS/headInfxMeanTemp.png", width = 6, height=4, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_mean_mean, y=Head_mean))+
   geom_errorbar(aes(ymin=Head_mean-Head_se, ymax=Head_mean+Head_se), color="gray20", width=0.1) +
  geom_errorbarh(aes(xmin=Temp_mean_mean-Temp_mean_se, xmax=Temp_mean_mean+Temp_mean_se), color="gray20", height=0.05) +
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Head Infection")+
  xlab("Mean Daily Temperature (C)")
dev.off()
```

#### Saliva Infection

I don't know if it necessarily worth it to consider saliva infection since there was no general trend found in the class and season model, but I will give it a shot.

```{r}
respV <- "Saliva"
predVs <- c("Temp_mean","RH_mean","Temp_min","RH_min", "Temp_max", "DTR", "hoursAbove31", "hoursBelow16")

hist(seasonInfSite$Saliva)

#create dataframe without NAs
myCols <- c(respV, predVs)
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)
#modDF[,respV] <- as.factor(modDF[,respV])
#levels(modDF[,respV]) <- c("no", "yes")


#split into testing and training - Don't do because only have 18 values
# set.seed(8675309)
# inds <- createDataPartition(modDF[,respV], p=.7, list=F, times=1)
# train <- modDF[inds,]
# test <- modDF[-inds,]

##glmnet
glmControl <- trainControl(method='LOOCV', 
                           #number=17,
                           returnResamp='none'
                           #preProcOptions = c("center", "corr", "scale")
                           )
set.seed(8675309)
glmModel <- train(modDF[, predVs[-c(3,4,6,8,7)]], modDF[, respV], 
                  method='glmnet',
                  trControl=glmControl)

plot(varImp(glmModel,scale=T))
glmModel$results
coef(glmModel$finalModel, glmModel$bestTune$lambda)
```

Glmnet drops four variables, leaving Temp_mean, RH_mean, Temp_max, and hoursAbove31. (RMSE=0.1620)

First run:
- Dropping tmax improves model (RMSE=0.1602)
- dropping hoursabove31 greatly improves model (RMSE=0.1525)

Decision: Drop hoursabove31

Second run: This is the best performing model

Final model: Temp_max, Temp_mean, RH_mean  (RMSE=0.1525, R2=0.4310)

**Second pass: lmer**

```{r}
respV <- "Saliva_mean"
predVs <- c("Temp_mean_mean","RH_mean_mean","Temp_min_mean","RH_min_mean", "Temp_max_mean", "DTR_mean", "hoursAbove31_mean", "hoursBelow16_mean")

#create dataframe without NAs
myCols <- c(respV, predVs, "block")
modDF <- seasonInfSite %>%
  dplyr::select(one_of(myCols)) 
modDF <- na.omit(modDF)

lmerMod1 <- lmer(Saliva_mean~ Temp_max_mean + (1|block), data=modDF) #highest marginal r2
lmerMod2 <- lmer(Saliva_mean~ Temp_mean_mean + (1|block), data=modDF)
lmerMod3 <- lmer(Saliva_mean~ RH_mean_mean + (1|block), data=modDF) #intercept error
lmerMod4 <- lmer(Saliva_mean~ Temp_mean_mean*RH_mean_mean+ (1|block), data=modDF) 
lmerMod5 <- lmer(Saliva_mean~ Temp_max_mean*RH_mean_mean+ (1|block), data=modDF)

piecewiseSEM::rsquared(list(lmerMod1, lmerMod2, lmerMod4, lmerMod5)) 

finalSaliva <- lmerMod1

MuMIn::r.squaredGLMM(finalSaliva)
summary(finalSaliva)
Anova(finalSaliva)
plot(finalSaliva)

#check predictive R2
preds <- predict(finalSaliva)
plot(preds, modDF$Saliva_mean)
abline(a=0, b=1)
cor(preds, modDF$Saliva_mean)
```

The best fitting model is based on the maximum temperature, but the effect is not significant. We can conclude, therefore that Saliva infection was not impacted by temperature.

```{r}

png(file="../figures/forMS/salivaInfxMaxTemp.png", width = 6, height=4, units="in", res=500, family="sans")
ggplot(data=seasonInfSite, aes(x=Temp_max_mean, y=Saliva_mean))+
  geom_errorbar(aes(ymin=Saliva_mean-Saliva_se, ymax=Saliva_mean+Saliva_se), color="gray20", width=0.1) +
  geom_errorbarh(aes(xmin=Temp_max_mean-Temp_max_se, xmax=Temp_max_mean+Temp_max_se), color="gray20", height=0.05) +
  geom_point(aes(color=class, shape=block), size=4) + 
  scale_color_manual(values=c(colRural, colSuburban, colUrban)) +
  theme_base() +
  ylab("Prop. Saliva Infection")+
  xlab("Maximum Daily Temperature (C)")
dev.off()
```


### Test 3: Winglength

We also want to know how winglength influences infection. One of our mechanisms has to do with the quality of mosquitoes, of which body size is a proxy.

Because we have found a significant effect of class on body and head infection, but no significant effect of climate, we are wondering if it is indirectly through body size. That is, microclimate leads to different sized mosquitoes, and different size mosquitoes are more or less susceptible to infection. This requires two tests:

* a) the relationship between wing size and infection
* b) the relationship between climate and wing size

#### Test 3.a Wing Size and Infection

```{r}
ggplot(data=seasonInfSite, aes(x=Wing_mean, y=Body_mean))+
  geom_point(aes(color=class))

wingInf <- seasonInf[seasonInf$Body %in% c(1,0),]

ggplot(data=wingInf, aes(Wing))+
  geom_histogram(aes(fill=class))+
  facet_wrap(~Body, dir="v")+
  scale_fill_manual(values=c("dodgerblue", "gray80", "maroon"))+
  #geom_vline(aes(xintercept=median(Wing)))+
  theme_base()+
  geom_vline(data=wingInf[wingInf$Body==1 & wingInf$class=="Rural",], aes(xintercept=median(Wing, na.rm=T)), color="dodgerblue")+
    geom_vline(data=wingInf[wingInf$Body==0 & wingInf$class=="Rural",], aes(xintercept=median(Wing, na.rm=T)), color="dodgerblue")+
    geom_vline(data=wingInf[wingInf$Body==1 & wingInf$class=="Suburban",], aes(xintercept=median(Wing, na.rm=T)), color="black")+
    geom_vline(data=wingInf[wingInf$Body==0 & wingInf$class=="Suburban",], aes(xintercept=median(Wing, na.rm=T)), color="black")+
      geom_vline(data=wingInf[wingInf$Body==1 & wingInf$class=="Urban",], aes(xintercept=median(Wing, na.rm=T)), color="maroon")+
        geom_vline(data=wingInf[wingInf$Body==0 & wingInf$class=="Urban",], aes(xintercept=median(Wing, na.rm=T)), color="maroon")
  
```

There really doesn't seem to be any trend between wing size and infection.  In both infected and uninfected mosquitoes, the size distribution is very similar. Urban mosquitoes are in general larger, but there is no difference between infected and uninfected.

```{r}
ggplot(data=seasonInf)+
  geom_histogram(aes(Wing))+
  facet_wrap(~site)

ggplot(data=seasonInf)+
  geom_boxplot(aes(y=Wing, x=factor(Body)))+
  facet_wrap(~block)

ggplot(data=seasonInf)+
  geom_boxplot(aes(y=Wing, x=factor(class)))+
  facet_wrap(~block)

wingMeans <- seasonInf %>%
  group_by(class, block, Body) %>%
  filter(Body %in% c(0,1)) %>%
  summarise(meanW=mean(Wing, na.rm=T), wingSE=sd(Wing, na.rm=T)/sqrt(n())) %>%
  ungroup()

ggplot(data=wingMeans, aes(x=class,group=factor(Body)))+
  geom_col(aes(y=meanW, group=factor(Body), fill=factor(Body)), position="dodge")+
  geom_errorbar(aes(ymin=meanW-wingSE, ymax=meanW+wingSE), color="gray20", width=0.1, position="dodge")+
  facet_wrap(~block)

median(seasonInf$Wing[seasonInf$block=="fall"], na.rm=T)
median(seasonInf$Wing[seasonInf$block=="summer"], na.rm=T)
mean(seasonInf$Wing[seasonInf$block=="fall"], na.rm=T)
mean(seasonInf$Wing[seasonInf$block=="summer"], na.rm=T)
```



